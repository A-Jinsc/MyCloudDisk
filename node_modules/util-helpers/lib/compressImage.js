'use strict';

var ut2 = require('ut2');
var loadImageWithBlob = require('./loadImageWithBlob.js');
var native = require('./utils/native.js');

function canvasToBlob(canvas, type, quality) {
    return new Promise(function (resolve) {
        canvas.toBlob(function (blob) {
            resolve(blob);
        }, type, quality);
    });
}
var compressImage = function (img, options) {
    if (options === void 0) { options = {}; }
    return new Promise(function (resolve, reject) {
        var width = options.width, height = options.height, rotate = options.rotate, _a = options.offset, offset = _a === void 0 ? [0, 0] : _a, _b = options.background, background = _b === void 0 ? '#fff' : _b, canvasWidth = options.canvasWidth, canvasHeight = options.canvasHeight, _c = options.format, format = _c === void 0 ? 'blob' : _c, _d = options.type, type = _d === void 0 ? 'image/jpeg' : _d, _e = options.quality, quality = _e === void 0 ? 0.8 : _e, beforeCompress = options.beforeCompress, beforeDraw = options.beforeDraw, afterDraw = options.afterDraw, ajaxOptions = options.ajaxOptions;
        loadImageWithBlob(img, ajaxOptions)
            .then(function (_a) {
            var image = _a.image, blob = _a.blob;
            var numWidth = ut2.toNumber(width);
            var numHeight = ut2.toNumber(height);
            var numQuality = ut2.toNumber(quality);
            if (numWidth) {
                image.width = numWidth;
            }
            if (numHeight) {
                image.height = numHeight;
            }
            beforeCompress === null || beforeCompress === void 0 ? void 0 : beforeCompress({ image: image, blob: blob }, options);
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            var info = { image: image, blob: blob, canvas: canvas, context: ctx };
            var numCanvasWidth = ut2.toNumber(typeof canvasWidth === 'function' ? canvasWidth(info, options) : canvasWidth);
            var numCanvasHeight = ut2.toNumber(typeof canvasHeight === 'function' ? canvasHeight(info, options) : canvasHeight);
            canvas.width = numCanvasWidth || image.width;
            canvas.height = numCanvasHeight || image.height;
            var bgIsTransparent = background === 'none' || background === 'transparent';
            if (bgIsTransparent) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            else {
                ctx.fillStyle = background;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            var internalOffset = [0, 0];
            if (rotate !== native.nativeUndefined) {
                ctx.translate(image.width / 2, image.height / 2);
                internalOffset = [-image.width / 2, -image.height / 2];
                ctx.rotate((rotate * Math.PI) / 180);
            }
            var outOffset = typeof offset === 'function' ? offset(info, options) : offset;
            beforeDraw === null || beforeDraw === void 0 ? void 0 : beforeDraw(info, options);
            var dx = internalOffset[0] + ut2.toNumber(outOffset[0]);
            var dy = internalOffset[1] + ut2.toNumber(outOffset[1]);
            ctx.drawImage(image, dx, dy, image.width, image.height);
            if (type === 'image/png' && bgIsTransparent) {
                ctx.globalCompositeOperation = 'destination-in';
                ctx.drawImage(image, dx, dy, image.width, image.height);
            }
            afterDraw === null || afterDraw === void 0 ? void 0 : afterDraw(info, options);
            if (format === 'blob') {
                canvasToBlob(canvas, type, numQuality).then(resolve).catch(reject);
            }
            else {
                resolve(canvas.toDataURL(type, numQuality));
            }
        })
            .catch(reject);
    });
};

module.exports = compressImage;
