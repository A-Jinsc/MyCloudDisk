(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.utilHelpers = {}));
})(this, (function (exports) { 'use strict';

    var nativeUndefined$1 = void 0;
    var stringUndefined = 'undefined';
    var stringObject = 'object';
    var objectProto = Object.prototype;
    var objectProtoToString = objectProto.toString;
    var objectProtoHasOwnProperty = objectProto.hasOwnProperty;
    var objectProtoPropertyIsEnumerable = objectProto.propertyIsEnumerable;
    var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
    var objectGetPrototypeOf = Object.getPrototypeOf;
    var objectKeys$1 = Object.keys;
    var functionProto = Function.prototype;
    var functionProtoToString = functionProto.toString;
    var symbolExisted = typeof Symbol !== stringUndefined;
    var symbolProto = symbolExisted ? Symbol.prototype : nativeUndefined$1;
    var mathMin = Math.min;
    var mathMax = Math.max;
    var mathRandom = Math.random;
    var mathFloor = Math.floor;
    var mathCeil = Math.ceil;
    var numberIsFinite = Number.isFinite;
    var globalThisExisted = typeof globalThis === stringObject && globalThis;
    var globalExisted = typeof global === stringObject && global;
    var selfExisted = typeof self === stringObject && self;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var numberTag = '[object Number]';
    var stringTag = '[object String]';
    var symbolTag = '[object Symbol]';
    var functionTags = ['Function', 'AsyncFunction', 'GeneratorFunction', 'Proxy'].map(function (item) { return '[object ' + item + ']'; });
    var blobTag = '[object Blob]';
    var fileTag = '[object File]';
    var objectTag = '[object Object]';

    function isArray(value) {
        return Array.isArray(value);
    }

    function isObjectLike(value) {
        return value !== null && typeof value === 'object';
    }

    function isObject(value) {
        return typeof value === 'function' || isObjectLike(value);
    }

    function getTag(value) {
        return objectProtoToString.call(value);
    }

    function isSymbol(value) {
        return typeof value === 'symbol' || getTag(value) === symbolTag;
    }

    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    function toNumber(value) {
        if (typeof value === 'number') {
            return value;
        }
        if (isSymbol(value)) {
            return NaN;
        }
        if (isObject(value)) {
            value = Number(value);
        }
        if (typeof value !== 'string') {
            return value === 0 ? value : +value;
        }
        value = value.trim();
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? parseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NaN : +value;
    }

    function toInteger(value) {
        var result = toNumber(value);
        if (!result || result === Infinity || result === -Infinity) {
            return result === result ? result : 0;
        }
        var remainder = result % 1;
        return remainder ? result - remainder : result;
    }

    function identity(value) {
        return value;
    }

    function isFunction(value) {
        if (typeof value === 'function') {
            return true;
        }
        var tag = getTag(value);
        return functionTags.some(function (item) { return item === tag; });
    }

    function isLength(value) {
        return typeof value === 'number' && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER;
    }

    function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
    }

    var nth = function (array, n) {
        if (n === void 0) { n = 0; }
        if (!isArrayLike(array)) {
            return nativeUndefined$1;
        }
        n += n < 0 ? array.length : 0;
        return array[n];
    };

    var MAX_VALUE = 1.7976931348623157e308;
    function toFinite(value) {
        if (!value) {
            return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === Infinity || value === -Infinity) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_VALUE;
        }
        return value === value ? value : 0;
    }

    function randomInt(lower, upper) {
        if (lower === void 0) { lower = 0; }
        if (upper === void 0) { upper = 1; }
        lower = toFinite(lower);
        upper = toFinite(upper);
        var min = mathCeil(mathMin(lower, upper) || 0);
        var max = mathFloor(mathMax(lower, upper) || 0);
        if (min > max) {
            var temp = min;
            min = max;
            max = temp;
        }
        return mathFloor(min + mathRandom() * (max - min + 1));
    }

    function getSymbols(object) {
        if (!objectGetOwnPropertySymbols || object === null) {
            return [];
        }
        return objectGetOwnPropertySymbols(object).filter(function (item) { return objectProtoPropertyIsEnumerable.call(object, item); });
    }

    function allKeys(object) {
        if (!isObject(object)) {
            return [];
        }
        return objectKeys$1(object).concat(getSymbols(object));
    }

    function createForEach(dir) {
        var forEach = function (collection, iteratee) {
            if (iteratee === void 0) { iteratee = identity; }
            var _keys = !isArrayLike(collection) && allKeys(collection);
            var len = (_keys || collection).length;
            var i = 0 ;
            while (i >= 0 && i < len) {
                var currentKey = _keys ? _keys[i] : i;
                if (iteratee(collection[currentKey], currentKey, collection) === false) {
                    break;
                }
                i += dir;
            }
            return collection;
        };
        return forEach;
    }

    var forEach = createForEach(1);

    function isNumber(value) {
        return typeof value === 'number' || getTag(value) === numberTag;
    }

    function isNil(value) {
        return value == null;
    }

    var symbolToString = symbolProto ? symbolProto.toString : nativeUndefined$1;
    function baseToString(value) {
        if (typeof value === 'string') {
            return value;
        }
        if (isArray(value)) {
            return '' + value.map(baseToString);
        }
        if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : '';
        }
        var result = '' + value;
        return result === '0' && 1 / value === -Infinity ? '-0' : result;
    }
    function toString(value) {
        return isNil(value) ? '' : baseToString(value);
    }

    var blobExisted = typeof Blob !== stringUndefined;
    function isBlob(value) {
        if (blobExisted && value instanceof Blob) {
            return true;
        }
        return getTag(value) === blobTag;
    }

    var objectCtorString = functionProtoToString.call(Object);
    function isPlainObject(value) {
        if (!isObjectLike(value) || getTag(value) !== objectTag) {
            return false;
        }
        var proto = objectGetPrototypeOf(Object(value));
        if (proto === null) {
            return true;
        }
        var Ctor = objectProtoHasOwnProperty.call(proto, 'constructor') && proto.constructor;
        return typeof Ctor === 'function' && Ctor instanceof Ctor && functionProtoToString.call(Ctor) === objectCtorString;
    }

    var fileExisted = typeof File !== stringUndefined;
    function isFile(value) {
        if (fileExisted && value instanceof File) {
            return true;
        }
        return getTag(value) === fileTag;
    }

    var freeGlobalThis = globalThisExisted && globalThis.Object === Object && globalThis;
    var freeGlobal = globalExisted && global.Object === Object && global;
    var freeSelf = selfExisted && self.Object === Object && self;
    var root = freeGlobalThis || freeGlobal || freeSelf || Function('return this')();

    function isFinite$1(value) {
        return numberIsFinite ? numberIsFinite(value) : typeof value === 'number' && root.isFinite(value);
    }

    function isNaN(value) {
        return isNumber(value) && root.isNaN(value);
    }

    function isPromiseLike(value) {
        return isObject(value) && typeof value.then === 'function';
    }

    function isString(value) {
        return typeof value === 'string' || getTag(value) === stringTag;
    }

    function decimalAdjust(type, value, precision) {
        if (precision === void 0) { precision = 0; }
        var func = Math[type];
        value = toNumber(value);
        precision = mathMin(toInteger(precision), 292);
        if (precision === 0 || !isFinite$1(value)) {
            return func(value);
        }
        var pair = toString(value).split('e');
        value = func(+(pair[0] + 'e' + (pair[1] ? +pair[1] + precision : precision)));
        pair = toString(value).split('e');
        return +(pair[0] + 'e' + (pair[1] ? +pair[1] - precision : -precision));
    }

    function round(number, precision) {
        return decimalAdjust('round', number, precision);
    }

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol, Iterator */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
        return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    function constant(value) {
        return function () {
            return value;
        };
    }

    function noop() { }

    var tryit = function (fn) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                var result = fn.apply(void 0, __spreadArray([], __read(args), false));
                if (isPromiseLike(result)) {
                    return result
                        .then(function (res) {
                        return [null, res];
                    })
                        .catch(function (err) {
                        return [err, nativeUndefined$1];
                    });
                }
                return [null, result];
            }
            catch (err) {
                return [err, nativeUndefined$1];
            }
        };
    };

    var idCounter = 0;
    '_' + mathRandom().toString(36).substring(2, 4);
    function uniqueId(prefix) {
        return '' + prefix + ++idCounter;
    }

    var reg$b = /^1[3456789]\d{9}$/;
    function isMobile(value) {
        var valueStr = toString(value);
        return reg$b.test(valueStr);
    }

    var reg$a = /^(0\d{2,3}-)?([2-9]\d{6,7})(-\d{1,6})?$/;
    function isTelephone(value) {
        var valueStr = toString(value);
        return reg$a.test(valueStr);
    }

    var reg$9 = /^\d{6}$/;
    function isPostcode(value) {
        var valueStr = toString(value);
        return reg$9.test(valueStr);
    }

    var regIdCard$1 = /^[1-9]\d{5}(19|20)?\d{2}((0[1-9])|(1[012]))(([0-2][1-9])|10|20|30|31)\d{3}(\d|X)?$/i;
    function check(id) {
        var index, sum;
        for (sum = index = 0; index < 17; index++) {
            sum += (Math.pow(2, 17 - index) % 11) * Number(id[index]);
        }
        var num = (12 - (sum % 11)) % 11;
        if (num < 10) {
            return num === Number(id[17]);
        }
        else {
            return id[17].toUpperCase() === 'X';
        }
    }
    function isIdCard(value, options) {
        if (options === void 0) { options = {}; }
        var _a = options.loose, loose = _a === void 0 ? false : _a, _b = options.checkCode, checkCode = _b === void 0 ? true : _b;
        var valueStr = toString(value);
        if (valueStr.length === 15 && loose) {
            return regIdCard$1.test(valueStr);
        }
        if (valueStr.length === 18 && regIdCard$1.test(valueStr)) {
            if (checkCode) {
                return check(valueStr);
            }
            return true;
        }
        return false;
    }

    var reg$8 = /^[\da-z]+([-._]?[\da-z]+)*@[\da-z]+([-.]?[\da-z]+)*(\.[a-z]{2,})+$/i;
    function isEmail(value) {
        var valueStr = toString(value);
        return reg$8.test(valueStr);
    }

    var reg$7 = /^[1-9]\d{4,10}$/;
    function isQQ(value) {
        var valueStr = toString(value);
        return reg$7.test(valueStr);
    }

    var reg$6 = /^[a-z]([-_a-z0-9]{5,19})+$/i;
    function isWX(value) {
        var valueStr = toString(value);
        return reg$6.test(valueStr);
    }

    var reg$5 = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}(([A-Z0-9]{4}[A-Z0-9挂学警港澳]{1})|([A-Z0-9]{5}[DF])|([DF][A-Z0-9]{5}))$/;
    function isVehicle(value) {
        var valueStr = toString(value);
        return reg$5.test(valueStr);
    }

    var reg$4 = /^[1-9]\d{9,20}$/;
    var regLoose = /^\d{8,30}$/;
    function sumCheckCode$2(numStr) {
        var numArr = (numStr + '').replace(/\D/g, '').split('').reverse();
        var sum = 0;
        for (var i = 0; i < numArr.length; i++) {
            var currNum = parseInt(numArr[i]);
            sum += i % 2 === 0 ? currNum * 2 - (currNum > 4 ? 9 : 0) : currNum;
        }
        var mod = sum % 10;
        return mod !== 0 ? 10 - mod : 0;
    }
    function isBankCard(value, options) {
        if (options === void 0) { options = {}; }
        var _a = options.loose, loose = _a === void 0 ? false : _a, _b = options.luhn, luhn = _b === void 0 ? false : _b;
        var valueStr = toString(value);
        var validateResult = loose ? regLoose.test(valueStr) : reg$4.test(valueStr);
        if (validateResult && luhn) {
            var precode = valueStr.substring(0, valueStr.length - 1);
            var checkCode = valueStr[valueStr.length - 1];
            return checkCode === String(sumCheckCode$2(precode));
        }
        return validateResult;
    }

    var baseReg$1 = /^[\dA-HJ-NPQRTUWXY]{2}\d{6}[\dA-HJ-NPQRTUWXY]{10}$/;
    var baseCodeArr = '0123456789ABCDEFGHJKLMNPQRTUWXY'.split('');
    function sumCheckCode$1(preCode) {
        var total = 0;
        var _loop_1 = function (i) {
            var index = baseCodeArr.findIndex(function (item) { return item === preCode[i]; });
            var wf = Math.pow(3, i) % 31;
            total += index * wf;
        };
        for (var i = 0; i < 17; i++) {
            _loop_1(i);
        }
        var remainder = total % 31;
        var checkCodeIndex = remainder !== 0 ? 31 - remainder : 0;
        return baseCodeArr[checkCodeIndex];
    }
    function isSocialCreditCode(value, options) {
        var valueStr = toString(value);
        var _a = (options || {}).checkCode, needCheckCode = _a === void 0 ? true : _a;
        var passBaseRule = baseReg$1.test(valueStr);
        if (!needCheckCode || !passBaseRule) {
            return passBaseRule;
        }
        var preCode = valueStr.substring(0, 17);
        var lastCode = valueStr.substring(valueStr.length - 1);
        var checkCode = sumCheckCode$1(preCode);
        return lastCode === checkCode;
    }

    var config$1 = {
        disableWarning: true
    };
    function setDisableWarning(bool) {
        config$1.disableWarning = !!bool;
    }

    function devWarn() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!config$1.disableWarning) {
            console.warn.apply(void 0, args);
        }
    }

    var regNumber = /\d/;
    var regLowerCaseLetter = /[a-z]/;
    var regUpperCaseLetter = /[A-Z]/;
    var regAllNumberAndLetter = /[\d|a-z]/gi;
    function hasHex(val) {
        return val.indexOf('\\x') > -1 || val.indexOf('\\u') > -1;
    }
    function hasSpecialCharacter(val, chars) {
        if (!chars || !val) {
            return false;
        }
        var specialChars = val.replace(regAllNumberAndLetter, '');
        if (!specialChars) {
            return false;
        }
        var regChars = hasHex(chars) ? new RegExp("[".concat(chars, "]")) : null;
        if (regChars) {
            return regChars.test(specialChars);
        }
        var ret = false;
        specialChars.split('').some(function (charItem) {
            if (chars.indexOf(charItem) > -1) {
                ret = true;
            }
            return ret;
        });
        return ret;
    }
    function hasUnallowableCharacter(val, chars) {
        if (!val) {
            return false;
        }
        var specialChars = val.replace(regAllNumberAndLetter, '');
        if (!specialChars) {
            return false;
        }
        else if (!chars) {
            return true;
        }
        var regChars = hasHex(chars) ? new RegExp("[^".concat(chars, "]")) : null;
        if (regChars) {
            return regChars.test(specialChars);
        }
        var ret = false;
        specialChars.split('').some(function (charItem) {
            if (chars.indexOf(charItem) === -1) {
                ret = true;
            }
            return ret;
        });
        return ret;
    }
    function validatePassword(value, options) {
        if (options === void 0) { options = {}; }
        var _a = options.level, level = _a === void 0 ? 2 : _a, _b = options.ignoreCase, ignoreCase = _b === void 0 ? false : _b, _c = options.special, special = _c === void 0 ? '\\x21-\\x2F\\x3A-\\x40\\x5B-\\x60\\x7B-\\x7E' : _c;
        var valStr = value;
        if (typeof value !== 'string') {
            devWarn("[validatePassword] value must be a string.");
            valStr = '';
        }
        var currentLevel = 0;
        var containesNumber = regNumber.test(valStr);
        var containesLowerCaseLetter = regLowerCaseLetter.test(valStr);
        var containesUpperCaseLetter = regUpperCaseLetter.test(valStr);
        var containesSpecialCharacter = hasSpecialCharacter(valStr, special);
        var containesUnallowableCharacter = hasUnallowableCharacter(valStr, special);
        if (containesNumber) {
            currentLevel += 1;
        }
        if (ignoreCase) {
            if (containesLowerCaseLetter || containesUpperCaseLetter) {
                currentLevel += 1;
            }
        }
        else {
            if (containesLowerCaseLetter) {
                currentLevel += 1;
            }
            if (containesUpperCaseLetter) {
                currentLevel += 1;
            }
        }
        if (containesSpecialCharacter) {
            currentLevel += 1;
        }
        var validated = currentLevel >= level && !containesUnallowableCharacter;
        return {
            validated: validated,
            level: currentLevel,
            containes: {
                number: containesNumber,
                lowerCaseLetter: containesLowerCaseLetter,
                upperCaseLetter: containesUpperCaseLetter,
                specialCharacter: containesSpecialCharacter,
                unallowableCharacter: containesUnallowableCharacter
            }
        };
    }

    function isPassword(value, options) {
        if (options === void 0) { options = {}; }
        var _a = options.level, level = _a === void 0 ? 2 : _a, _b = options.ignoreCase, ignoreCase = _b === void 0 ? false : _b, _c = options.special, special = _c === void 0 ? '\\x21-\\x2F\\x3A-\\x40\\x5B-\\x60\\x7B-\\x7E' : _c;
        return validatePassword(value, { level: level, ignoreCase: ignoreCase, special: special }).validated;
    }

    var reg$3 = /^((e[\da-z])|(de)|(se)|(pe)|([khm][\da-z]))[\da-z]{7}$/i;
    function isPassport(value) {
        var valueStr = toString(value);
        return reg$3.test(valueStr);
    }

    var URLExisted = typeof URL !== 'undefined';

    var nativeUndefined = void 0;
    var objectKeys = Object.keys;
    var objectValues = Object.values;
    var createObjectURL = URLExisted ? URL.createObjectURL : constant('');
    var revokeObjectURL = URLExisted ? URL.revokeObjectURL : noop;

    var chineseDictionary = {
        chineseBasic: '[\u4e00-\u9fa5]',
        chineseExtend: '[\u9ea6-\u9fff]',
        chineseExtend2: '[\uF900-\uFAD9]',
        chineseExtendA: '[\u3400-\u4DBF]',
        chineseExtendB: "[\uD840\uDC00-\uD869\uDEDF]",
        chineseExtendC: "[\uD869\uDF00-\uD86D\uDF38]",
        chineseExtendD: "[\uD86D\uDF40-\uD86E\uDC1D]",
        chineseExtendE: "[\uD86E\uDC20-\uD873\uDEA1]",
        chineseExtendF: "[\uD873\uDEB0-\uD87A\uDFE0]",
        chineseExtendG: "[\uD880\uDC00-\uD884\uDF4A]",
        chineseExtendH: "[\uD884\uDF50-\uD888\uDFAF]",
        chineseExtendI: "[\uD87A\uDFF0-\uD87B\uDE5D]"
    };
    var looseChineseRegExp = chineseDictionary.chineseBasic + '+';
    var chineseRegExp = '^' + chineseDictionary.chineseBasic + '+$';
    var chineseWithExtend = '(?:' + objectValues(chineseDictionary).join('|') + ')';
    var looseChineseExtendRegExp = chineseWithExtend + '+';
    var chineseExtendRegExp = '^' + chineseWithExtend + '+$';
    var supportRegExpUnicode = RegExp.prototype.hasOwnProperty('unicode');
    function isChinese(value, options) {
        if (options === void 0) { options = {}; }
        var _a = options.loose, loose = _a === void 0 ? false : _a, _b = options.useExtend, useExtend = _b === void 0 ? false : _b;
        var valueStr = toString(value);
        var basicRegExp = loose ? looseChineseRegExp : chineseRegExp;
        var extendRegExp = loose ? looseChineseExtendRegExp : chineseExtendRegExp;
        var hasExtend = useExtend && supportRegExpUnicode;
        var resultRegExp = hasExtend ? extendRegExp : basicRegExp;
        var flag = hasExtend ? 'u' : nativeUndefined;
        var reg = new RegExp(resultRegExp, flag);
        return reg.test(valueStr);
    }

    var reg$2 = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
    function isIPv4(value) {
        var valueStr = toString(value);
        return reg$2.test(valueStr);
    }

    var reg$1 = /^((([0-9A-F]{1,4}:){7}([0-9A-F]{1,4}|:))|(([0-9A-F]{1,4}:){6}(:[0-9A-F]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|\d{1,2})(\.(25[0-5]|2[0-4]\d|1\d\d|\d{1,2})){3})|:))|(([0-9A-F]{1,4}:){5}(((:[0-9A-F]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|\d{1,2})(\.(25[0-5]|2[0-4]\d|1\d\d|\d{1,2})){3})|:))|(([0-9A-F]{1,4}:){4}(((:[0-9A-F]{1,4}){1,3})|((:[0-9A-F]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|\d{1,2})(\.(25[0-5]|2[0-4]\d|1\d\d|\d{1,2})){3}))|:))|(([0-9A-F]{1,4}:){3}(((:[0-9A-F]{1,4}){1,4})|((:[0-9A-F]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|\d{1,2})(\.(25[0-5]|2[0-4]\d|1\d\d|\d{1,2})){3}))|:))|(([0-9A-F]{1,4}:){2}(((:[0-9A-F]{1,4}){1,5})|((:[0-9A-F]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|\d{1,2})(\.(25[0-5]|2[0-4]\d|1\d\d|\d{1,2})){3}))|:))|(([0-9A-F]{1,4}:){1}(((:[0-9A-F]{1,4}){1,6})|((:[0-9A-F]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|\d{1,2})(\.(25[0-5]|2[0-4]\d|1\d\d|\d{1,2})){3}))|:))|(:(((:[0-9A-F]{1,4}){1,7})|((:[0-9A-F]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|\d{1,2})(\.(25[0-5]|2[0-4]\d|1\d\d|\d{1,2})){3}))|:)))(%.+)?$/i;
    function isIPv6(value) {
        var valueStr = toString(value);
        return reg$1.test(valueStr);
    }

    var protocalReg = '[\\w-.]+:\\/\\/';
    var credentialsReg = '[-;:&=\\+\\$,\\w]+@';
    var serverReg = 'localhost|(([^\\s:\\/]+?\\.)+?[^\\s:\\/]+)';
    var portReg = ':\\d+';
    var pathReg = '\\/.*';
    var searchReg = '\\?.*';
    var hashReg = '#.*';
    var regWithProtocal = new RegExp("^".concat(protocalReg, "(?:").concat(credentialsReg, ")?(?:").concat(serverReg, ")(?:").concat(portReg, ")?(?:").concat(pathReg, ")*(?:").concat(searchReg, ")?(?:").concat(hashReg, ")?$"));
    var regNonProtocal = new RegExp("^(?:".concat(serverReg, ")(?:").concat(portReg, ")?(?:").concat(pathReg, ")*(?:").concat(searchReg, ")?(?:").concat(hashReg, ")?$"));
    function isUrl(value) {
        var valueStr = toString(value);
        return regWithProtocal.test(valueStr) || regNonProtocal.test(valueStr);
    }

    var baseReg = /^\d{15}$/;
    function sumCheckCode(preCode) {
        var retNum;
        var pj = 10;
        for (var j = 0; j < 14; j++) {
            var sj = pj + Number(preCode[j]);
            var sj10 = sj % 10;
            sj10 = sj10 === 0 ? 10 : sj10;
            var pj1 = sj10 * 2;
            pj = pj1 % 11;
        }
        if (pj === 1) {
            retNum = 0;
        }
        else {
            retNum = 11 - pj;
        }
        return retNum;
    }
    function isBusinessLicense(value, options) {
        if (options === void 0) { options = {}; }
        var valueStr = toString(value);
        var _a = options.checkCode, needCheckCode = _a === void 0 ? true : _a;
        var passBaseRule = baseReg.test(valueStr);
        if (!needCheckCode || !passBaseRule) {
            return passBaseRule;
        }
        var preCode = valueStr.substring(0, 14);
        var lastCode = valueStr.substring(valueStr.length - 1);
        var checkCode = sumCheckCode(preCode);
        return lastCode === String(checkCode);
    }

    var regHMCard = /^[hm]{1}([0-9]{10}|[0-9]{8})$/i;
    function isHMCard(value) {
        var valueStr = toString(value);
        return regHMCard.test(valueStr);
    }

    var regTWCard = /^\d{8}$/i;
    var singleRegTWCard = /^[\da-z]{10,12}$/i;
    function isTWCard(value, options) {
        if (options === void 0) { options = {}; }
        var _a = options.loose, loose = _a === void 0 ? false : _a;
        var valueStr = toString(value);
        if (regTWCard.test(valueStr)) {
            return true;
        }
        return loose ? singleRegTWCard.test(valueStr) : false;
    }

    var reg = /^[A-Z]{6}[A-Z\d]{2}(?:[A-Z\d]{3})?$/;
    function isSwiftCode(value) {
        var valueStr = toString(value);
        return reg.test(valueStr);
    }

    function isValidNumber(value, strict) {
        if (strict === void 0) { strict = false; }
        var ret;
        if (strict) {
            ret = typeof value === 'string' && value !== '' ? Number(value) : value;
        }
        else {
            if (typeof value === 'number') {
                ret = value;
            }
            else if (isSymbol(value)) {
                ret = Number.NaN;
            }
            else {
                ret = Number(value);
            }
        }
        return typeof ret === 'number' && !isNaN(ret);
    }

    var checkResult = function () {
        var args_1 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args_1[_i] = arguments[_i];
        }
        return __awaiter(void 0, __spreadArray([], __read(args_1), false), void 0, function (fn) {
            var _a, _b, err, ret;
            if (fn === void 0) { fn = function () { return true; }; }
            var args = [];
            for (_a = 1; _a < arguments.length; _a++) {
                args[_a - 1] = arguments[_a];
            }
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4, tryit(fn).apply(void 0, __spreadArray([], __read(args), false))];
                    case 1:
                        _b = __read.apply(void 0, [_c.sent(), 2]), err = _b[0], ret = _b[1];
                        return [2, !err && ret !== false];
                }
            });
        });
    };

    var radixReg = /^[-+]?0[b|o|x]\d+/i;
    var dotNumberStringReg = /^\.\d+/;
    function transformEffectiveNumber(value) {
        var ret;
        if (isString(value)) {
            ret = value.trim();
            if (ret === '') {
                ret = Number(ret);
            }
            else if (radixReg.test(ret) || dotNumberStringReg.test(ret)) {
                ret = toNumber(ret);
            }
            else if (isNaN(Number(ret))) {
                ret = Number.NaN;
            }
        }
        else if (isSymbol(value)) {
            ret = Number.NaN;
        }
        else if (!isNumber(value)) {
            ret = Number(value);
        }
        else {
            ret = value;
        }
        if (isNaN(ret)) {
            return Number.NaN;
        }
        return ret;
    }
    function isScientificNumber(num) {
        return /\d+\.?\d*e[+-]*\d+/i.test(num);
    }
    function strip(num, precision) {
        if (precision === void 0) { precision = 12; }
        return +parseFloat(num.toPrecision(precision));
    }
    function digitLength(num) {
        var eSplit = num.toString().split(/e/i);
        var len = (eSplit[0].split('.')[1] || '').length - +(eSplit[1] || 0);
        return len > 0 ? len : 0;
    }
    function float2Fixed(num) {
        var strNum = String(num);
        if (!isScientificNumber(strNum)) {
            return Number(strNum.replace('.', ''));
        }
        var dLen = digitLength(num);
        return dLen > 0 ? strip(+num * Math.pow(10, dLen)) : +num;
    }
    function checkBoundary(num) {
        if (+num > MAX_SAFE_INTEGER || +num < MIN_SAFE_INTEGER) {
            devWarn("".concat(num, " is beyond boundary when transfer to integer, the results may not be accurate"));
        }
    }
    function trimLeftZero(num) {
        var reg = /^([+-])?(0+)([0-9.]+)$/;
        var result = reg.exec(num);
        var sign;
        if (result) {
            sign = result[1] || '';
            return sign + (result[3][0] === '.' ? '0' + result[3] : result[3]);
        }
        return num;
    }

    function checkNumber(num) {
        if (!isValidNumber(num)) {
            devWarn("".concat(num, " invalid parameter."));
            return false;
        }
        if (typeof num === 'number') {
            checkBoundary(num);
        }
        return true;
    }
    function formatInt(intStr, thousand) {
        var txt = '';
        intStr = trimLeftZero(intStr);
        intStr = intStr[0] === '+' ? intStr.substring(1) : intStr;
        var negativeSymbol = Number(intStr) < 0 ? '-' : '';
        var reArr = negativeSymbol ? intStr.substring(1).split('').reverse() : intStr.split('').reverse();
        for (var i = 0; i < reArr.length; i++) {
            txt += reArr[i] + ((i + 1) % 3 === 0 && i + 1 !== reArr.length ? thousand : '');
        }
        return negativeSymbol + txt.split('').reverse().join('');
    }
    function formatDec(decStr, precision, decimal) {
        if (precision === 0) {
            return '';
        }
        var zero = 0;
        var ret = '';
        if (decStr && Number(decStr) > 0) {
            var tmpNum = parseFloat('0.' + decStr);
            ret = tmpNum.toFixed(precision).substring(2);
        }
        else {
            ret = zero.toFixed(precision).substring(2);
        }
        return decimal + ret;
    }
    var formatMoney = function (num, options) {
        if (options === void 0) { options = {}; }
        var _a = options.precision, precision = _a === void 0 ? 2 : _a, symbol = options.symbol, _b = options.thousand, thousand = _b === void 0 ? ',' : _b, _c = options.decimal, decimal = _c === void 0 ? '.' : _c, _d = options.strict, strict = _d === void 0 ? true : _d;
        if (!checkNumber(num) || (strict && (!isString(num) || num === '') && !isNumber(num))) {
            return '';
        }
        if (typeof num === 'number' && !isFinite(num)) {
            return num + '';
        }
        if (typeof precision !== 'number' || isNaN(precision) || precision < 0) {
            precision = 2;
        }
        else if (precision > 10) {
            precision = 10;
        }
        symbol = typeof symbol === 'string' ? symbol : '';
        thousand = typeof thousand === 'string' ? thousand : ',';
        decimal = typeof decimal === 'string' ? decimal : '.';
        var strNum = transformEffectiveNumber(num) + '';
        var _e = __read(strNum.split('.'), 2), intStr = _e[0], decStr = _e[1];
        return symbol + formatInt(intStr, thousand) + formatDec(decStr, precision, decimal);
    };

    function formatBankCard(bankCardNo, options) {
        if (bankCardNo === void 0) { bankCardNo = ''; }
        var _a = options || {}, _b = _a.spaceMark, spaceMark = _b === void 0 ? ' ' : _b, _c = _a.length, length = _c === void 0 ? 4 : _c;
        var reg = new RegExp("(.{".concat(length, "})"), 'g');
        var regChar = new RegExp("".concat(spaceMark), 'g');
        var realValue = toString(bankCardNo).replace(regChar, '');
        var str = realValue.replace(reg, "$1".concat(spaceMark));
        return realValue.length % length === 0 ? str.substring(0, str.length - 1) : str;
    }

    function replaceChar(str, options) {
        if (str === void 0) { str = ''; }
        if (options === void 0) { options = {}; }
        var _a = options.char, char = _a === void 0 ? '*' : _a, exclude = options.exclude;
        var _b = options.start, start = _b === void 0 ? 3 : _b, _c = options.end, end = _c === void 0 ? -4 : _c, repeat = options.repeat;
        var realStr = toString(str);
        var strLen = realStr.length;
        if (Math.abs(start) >= strLen) {
            return realStr;
        }
        start = start >= 0 ? start : strLen + start;
        end = end >= 0 ? end : strLen + end;
        if (start >= end) {
            return realStr;
        }
        var middleStr = realStr.substring(start, end);
        if (exclude) {
            var reg = new RegExp("[^".concat(exclude, "]"), 'g');
            middleStr = middleStr.replace(reg, char);
        }
        else {
            repeat = typeof repeat === 'number' && repeat >= 0 ? repeat : middleStr.length;
            middleStr = char.repeat(repeat);
        }
        return realStr.substring(0, start) + middleStr + realStr.substring(end);
    }

    var chnNumberChar = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九'];
    var chnUnitChar = ['', '十', '百', '千'];
    var big5NumberChar = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖'];
    var big5UnitChar = ['', '拾', '佰', '仟'];
    var numberChar;
    var unitChar;
    var unitSection;
    function sectionToChinese(section) {
        var str = '';
        var chnstr = '';
        var zero = false;
        var unitPos = 0;
        while (section > 0) {
            var v = section % 10;
            if (v == 0) {
                if (zero) {
                    zero = false;
                    chnstr = numberChar[v] + chnstr;
                }
            }
            else {
                zero = true;
                str = numberChar[v];
                str += unitChar[unitPos];
                chnstr = str + chnstr;
            }
            unitPos++;
            section = Math.floor(section / 10);
        }
        return chnstr;
    }
    function convertInteger(num) {
        var numInt = Math.floor(num);
        var unitPos = 0;
        var strIns = '';
        var chnStr = '';
        var needZero = false;
        if (numInt === 0) {
            return numberChar[0];
        }
        while (numInt > 0) {
            var section = numInt % 10000;
            if (needZero) {
                chnStr = numberChar[0] + chnStr;
            }
            strIns = sectionToChinese(section);
            strIns += section !== 0 ? unitSection[unitPos] : unitSection[0];
            chnStr = strIns + chnStr;
            needZero = section < 1000 && section > 0;
            numInt = Math.floor(numInt / 10000);
            unitPos++;
        }
        return chnStr;
    }
    function convertDecimal(num) {
        var strNum = num + '';
        var index = strNum.indexOf('.');
        var ret = '';
        if (index > -1) {
            var decimalStr = strNum.slice(index + 1);
            ret = mapNumberChar(decimalStr);
        }
        return ret;
    }
    function mapNumberChar(num) {
        var strNum = num + '';
        var ret = '';
        for (var i = 0, len = strNum.length; i < len; i++) {
            ret += numberChar[parseInt(strNum[i])];
        }
        return ret;
    }
    function numberToChinese(num, options) {
        if (options === void 0) { options = {}; }
        var _a = options.big5, big5 = _a === void 0 ? false : _a, _b = options.unit, unit = _b === void 0 ? true : _b, _c = options.zero, zero = _c === void 0 ? '' : _c, _d = options.negative, negative = _d === void 0 ? '负' : _d, _e = options.unitConfig, unitConfig = _e === void 0 ? {} : _e;
        var _f = options.decimal, decimal = _f === void 0 ? '' : _f;
        if (typeof num !== 'number' || isNaN(num)) {
            devWarn("\u53C2\u6570\u9519\u8BEF ".concat(num, "\uFF0C\u8BF7\u4F20\u5165\u6570\u5B57"));
            return '';
        }
        checkBoundary(num);
        if (big5) {
            numberChar = big5NumberChar.slice();
            unitChar = big5UnitChar.slice();
            decimal = decimal || '點';
        }
        else {
            numberChar = chnNumberChar.slice();
            unitChar = chnUnitChar.slice();
            decimal = decimal || '点';
        }
        var unitWan = unitConfig.w || '万';
        var unitYi = unitConfig.y || '亿';
        var unitWanYi = unitWan + unitYi;
        unitSection = ['', unitWan, unitYi, unitWanYi];
        if (zero) {
            numberChar[0] = zero;
        }
        var preStr = num < 0 ? negative : '';
        var chnInteger;
        var numAbs = Math.abs(num);
        if (unit) {
            chnInteger = convertInteger(numAbs);
        }
        else {
            chnInteger = mapNumberChar(Math.floor(numAbs));
        }
        var chnDecimal = convertDecimal(numAbs);
        return chnDecimal ? "".concat(preStr).concat(chnInteger).concat(decimal).concat(chnDecimal) : "".concat(preStr).concat(chnInteger);
    }

    function bytesToSize(bytes, options) {
        if (options === void 0) { options = {}; }
        var _a = options.spaceMark, spaceMark = _a === void 0 ? ' ' : _a, _b = options.precision, precision = _b === void 0 ? 2 : _b;
        var numBytes = typeof bytes !== 'number' ? Number(bytes) : bytes;
        if (numBytes === 0 || isNaN(numBytes))
            return "0".concat(spaceMark, "B");
        var k = 1024;
        var sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        var i = Math.floor(Math.log(numBytes) / Math.log(k));
        return sizes[i] ? "".concat(Number((numBytes / Math.pow(k, i)).toFixed(precision))).concat(spaceMark).concat(sizes[i]) : numBytes + '';
    }

    var regIdCard = /^(\d{2})(\d{2})(\d{2})((?:\d{2})?\d{2})(\d{2})(\d{2})\d{2}(\d)(?:\d|X)?$/i;
    var Provinces = [
        ['11', '北京市'],
        ['12', '天津市'],
        ['13', '河北省'],
        ['14', '山西省'],
        ['15', '内蒙古自治区'],
        ['21', '辽宁省'],
        ['22', '吉林省'],
        ['23', '黑龙江省'],
        ['31', '上海市'],
        ['32', '江苏省'],
        ['33', '浙江省'],
        ['34', '安徽省'],
        ['35', '福建省'],
        ['36', '江西省'],
        ['37', '山东省'],
        ['41', '河南省'],
        ['42', '湖北省'],
        ['43', '湖南省'],
        ['44', '广东省'],
        ['45', '广西壮族自治区'],
        ['46', '海南省'],
        ['50', '重庆市'],
        ['51', '四川省'],
        ['52', '贵州省'],
        ['53', '云南省'],
        ['54', '西藏自治区'],
        ['61', '陕西省'],
        ['62', '甘肃省'],
        ['63', '青海省'],
        ['64', '宁夏回族自治区'],
        ['65', '新疆维吾尔自治区'],
        ['71', '台湾省'],
        ['83', '台湾省'],
        ['81', '香港特别行政区'],
        ['82', '澳门特别行政区']
    ];
    function parseIdCard(id) {
        var match = regIdCard.exec(id);
        if (!match) {
            return null;
        }
        var origin = {
            province: match[1],
            city: match[2],
            area: match[3],
            year: match[4],
            month: match[5],
            day: match[6],
            gender: match[7]
        };
        var province = Provinces.find(function (item) { return item[0] === origin.province; });
        if (!province) {
            return null;
        }
        var birthday = "".concat(origin.year, "-").concat(origin.month, "-").concat(origin.day);
        var gender = Number(origin.gender) % 2 === 0 ? '女' : '男';
        return {
            province: province[1],
            birthday: birthday,
            gender: gender,
            origin: origin
        };
    }

    function setDataURLPrefix(data, mimeType, base64) {
        if (mimeType === void 0) { mimeType = 'image/png'; }
        if (base64 === void 0) { base64 = true; }
        return "data:".concat(mimeType).concat(base64 ? ';base64' : '', ",").concat(data);
    }

    var safeDate = function (value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var safeValue = typeof value === 'string' ? value.replace(/[\\.-]/g, '/') : value;
        if (args && args.length > 0) {
            return new (Date.bind.apply(Date, __spreadArray([void 0, safeValue], __read(args), false)))();
        }
        return typeof safeValue === 'undefined' ? new Date() : new Date(safeValue);
    };

    function formatMobile(mobileNo, options) {
        if (mobileNo === void 0) { mobileNo = ''; }
        var _a = (options || {}).spaceMark, spaceMark = _a === void 0 ? ' ' : _a;
        var regChar = new RegExp(spaceMark, 'g');
        var realValue = toString(mobileNo).replace(regChar, '').substring(0, 11);
        if (realValue.length > 7) {
            return realValue.replace(/^(...)(....)/g, "$1".concat(spaceMark, "$2").concat(spaceMark));
        }
        if (realValue.length > 3) {
            return realValue.replace(/^(...)/g, "$1".concat(spaceMark));
        }
        return realValue;
    }

    function padZero(value, size) {
        if (size === void 0) { size = 2; }
        var str = toString(value);
        var len = str.length;
        if (typeof size !== 'number' || size < 0) {
            size = 0;
        }
        if (len < size) {
            return '0'.repeat(size - len) + str;
        }
        return str;
    }

    var transformObjectValue = function (data, fn, deep) {
        if (deep === void 0) { deep = true; }
        if (isPlainObject(data)) {
            var result_1 = {};
            forEach(data, function (value, key) {
                var newValue = deep && (isPlainObject(value) || isArray(value)) ? transformObjectValue(value, fn) : fn(value, key);
                result_1[key] = newValue;
            });
            return result_1;
        }
        else if (isArray(data)) {
            var result_2 = [];
            forEach(data, function (value, index) {
                var newValue = deep && (isPlainObject(value) || isArray(value)) ? transformObjectValue(value, fn) : fn(value, index);
                result_2.push(newValue);
            });
            return result_2;
        }
        return data;
    };

    function times() {
        var nums = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nums[_i] = arguments[_i];
        }
        var num1 = nums[0];
        var num2 = nums[1] === void 0 ? 1 : nums[1];
        var rest = nums.slice(2);
        if (rest.length > 0) {
            return times.apply(void 0, [times(num1, num2)].concat(rest));
        }
        num1 = transformEffectiveNumber(num1);
        num2 = transformEffectiveNumber(num2);
        if (isNaN(num1) || isNaN(num2)) {
            return Number.NaN;
        }
        var num1Changed = float2Fixed(num1);
        var num2Changed = float2Fixed(num2);
        var baseNum = digitLength(num1) + digitLength(num2);
        var leftValue = num1Changed * num2Changed;
        checkBoundary(leftValue);
        return leftValue / Math.pow(10, baseNum);
    }

    function plus() {
        var nums = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nums[_i] = arguments[_i];
        }
        var num1 = nums[0];
        var num2 = nums[1] === void 0 ? 0 : nums[1];
        var rest = nums.slice(2);
        if (rest.length > 0) {
            return plus.apply(void 0, [plus(num1, num2)].concat(rest));
        }
        num1 = transformEffectiveNumber(num1);
        num2 = transformEffectiveNumber(num2);
        if (isNaN(num1) || isNaN(num2)) {
            return Number.NaN;
        }
        var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2)));
        return (times(num1, baseNum) + times(num2, baseNum)) / baseNum;
    }

    function minus() {
        var nums = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nums[_i] = arguments[_i];
        }
        var num1 = nums[0];
        var num2 = nums[1] === void 0 ? 0 : nums[1];
        var rest = nums.slice(2);
        if (rest.length > 0) {
            return minus.apply(void 0, [minus(num1, num2)].concat(rest));
        }
        num1 = transformEffectiveNumber(num1);
        num2 = transformEffectiveNumber(num2);
        if (isNaN(num1) || isNaN(num2)) {
            return Number.NaN;
        }
        var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2)));
        return (times(num1, baseNum) - times(num2, baseNum)) / baseNum;
    }

    function divide() {
        var nums = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nums[_i] = arguments[_i];
        }
        var num1 = nums[0];
        var num2 = nums[1] === void 0 ? 1 : nums[1];
        var rest = nums.slice(2);
        if (rest.length > 0) {
            return divide.apply(void 0, [divide(num1, num2)].concat(rest));
        }
        num1 = transformEffectiveNumber(num1);
        num2 = transformEffectiveNumber(num2);
        if (isNaN(num1) || isNaN(num2)) {
            return Number.NaN;
        }
        var num1Changed = float2Fixed(num1);
        var num2Changed = float2Fixed(num2);
        checkBoundary(num1Changed);
        checkBoundary(num2Changed);
        return times(num1Changed / num2Changed, strip(Math.pow(10, digitLength(num2) - digitLength(num1))));
    }

    function _round(num, precision) {
        if (precision === void 0) { precision = 0; }
        return round(num, precision);
    }

    function gcd() {
        var nums = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nums[_i] = arguments[_i];
        }
        var num1 = nums[0];
        var num2 = nums[1] === void 0 ? 0 : nums[1];
        var rest = nums.slice(2);
        if (rest.length > 0) {
            return gcd.apply(void 0, [gcd(num1, num2)].concat(rest));
        }
        num1 = Math.abs(round(num1));
        num2 = Math.abs(round(num2));
        if (isNaN(num1) || isNaN(num2)) {
            return Number.NaN;
        }
        if (num1 === 0 && num2 === 0) {
            return 0;
        }
        if (num1 === 0) {
            return num2;
        }
        if (num2 === 0) {
            return num1;
        }
        var temp = num2;
        if (num1 < num2) {
            temp = num1;
            num1 = num2;
            num2 = temp;
        }
        while (temp) {
            temp = num1 % num2;
            num1 = num2;
            num2 = temp;
        }
        return toNumber(num1);
    }

    function lcm() {
        var nums = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nums[_i] = arguments[_i];
        }
        var args = nums.map(function (item) { return Math.abs(round(item)); });
        if (args.length === 1) {
            args = args.concat([1]);
        }
        var product = args.indexOf(0) > -1 ? 0 : times.apply(void 0, __spreadArray([], __read(args), false));
        return divide(product, gcd.apply(void 0, __spreadArray([], __read(args), false)));
    }

    function ajax(url, options) {
        var _a = options || {}, _b = _a.method, method = _b === void 0 ? 'get' : _b, _c = _a.data, data = _c === void 0 ? null : _c, timeout = _a.timeout, headers = _a.headers, _d = _a.withCredentials, withCredentials = _d === void 0 ? false : _d, _e = _a.async, async = _e === void 0 ? true : _e, _f = _a.user, user = _f === void 0 ? null : _f, _g = _a.password, password = _g === void 0 ? null : _g, responseType = _a.responseType, onReadyStateChange = _a.onReadyStateChange, onLoadStart = _a.onLoadStart, onProgress = _a.onProgress, onAbort = _a.onAbort, onTimeout = _a.onTimeout, onError = _a.onError, onLoad = _a.onLoad, onLoadEnd = _a.onLoadEnd;
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open(method.toLowerCase(), url, async, user, password);
            if (onReadyStateChange) {
                xhr.onreadystatechange = onReadyStateChange;
            }
            if (typeof timeout === 'number' && timeout > 0) {
                xhr.timeout = timeout;
            }
            xhr.withCredentials = withCredentials;
            if (responseType) {
                xhr.responseType = responseType;
            }
            if (typeof headers === 'object') {
                objectKeys(headers).map(function (item) {
                    xhr.setRequestHeader(item, headers[item]);
                });
            }
            var wrapSuccess = function (cb) {
                return function (e) {
                    resolve(e);
                    cb === null || cb === void 0 ? void 0 : cb.call(xhr, e);
                };
            };
            var wrapError = function (cb) {
                return function (e) {
                    reject(e);
                    cb === null || cb === void 0 ? void 0 : cb.call(xhr, e);
                };
            };
            var events = {
                loadstart: onLoadStart,
                progress: onProgress,
                abort: wrapError(onAbort),
                timeout: wrapError(onTimeout),
                error: wrapError(onError),
                load: wrapSuccess(onLoad),
                loadend: onLoadEnd
            };
            var eventKeys = objectKeys(events);
            eventKeys.map(function (item) {
                var func = events[item];
                if (func) {
                    xhr.addEventListener(item, func);
                }
            });
            xhr.send(data);
        });
    }

    function isUploadFile(fileObj) {
        if (isObjectLike(fileObj) && isString(fileObj.name)) {
            return true;
        }
        return false;
    }

    function getExtname(path) {
        return isString(path) && path.indexOf('.') > 0 ? '.' + nth(path.split('.'), -1) : '';
    }

    function checkFileType(file, accept) {
        var _a, _b;
        var isFileType = isFile(file);
        if (!isFileType && !isUploadFile(file)) {
            return false;
        }
        if (!isString(accept)) {
            accept = toString(accept);
        }
        accept = accept.trim();
        if (!accept || accept === '*') {
            return true;
        }
        var ret = false;
        var types = accept.toLowerCase().split(/,(?:\s+)?/);
        var fileName = (file.name || (!isFileType && (file.fileName || ((_a = file.originFileObj) === null || _a === void 0 ? void 0 : _a.name))) || '').toLowerCase();
        var fileType = file.type || (!isFileType && ((_b = file.originFileObj) === null || _b === void 0 ? void 0 : _b.type)) || '';
        var fileUrl = (!isFileType && file.url) || '';
        types.some(function (type) {
            if (type === '*' || fileType === type || (type.indexOf('.') === 0 && (getExtname(fileName) === type || getExtname(fileUrl) === type))) {
                ret = true;
            }
            else if (type.includes('/*') && fileType.includes('/')) {
                var match = type.match(/(.*)\/\*/);
                var fileParentType = fileType.split('/')[0];
                if (match && match[1] === fileParentType) {
                    ret = true;
                }
            }
            return ret;
        });
        return ret;
    }

    var SuccessResponseStatus = [200, 304];
    function getFileBlob(file, ajaxOptions) {
        return new Promise(function (resolve, reject) {
            if (isBlob(file)) {
                resolve(file);
            }
            else {
                ajax(file, __assign({ responseType: 'blob' }, ajaxOptions))
                    .then(function (ev) {
                    var responseStatus = ev.target.status;
                    if (SuccessResponseStatus.indexOf(responseStatus) !== -1) {
                        resolve(ev.target.response);
                    }
                    else {
                        var err = new Error("The file does not support get requests, responseStatus ".concat(responseStatus, ", '").concat(file, "'."));
                        console.error(err);
                        reject(err);
                    }
                })
                    .catch(function (err) {
                    console.error(new Error("Failed to request file. ".concat(err)));
                    reject(err);
                });
            }
        });
    }

    function loadImage(img) {
        return new Promise(function (resolve, reject) {
            var imgIsBlob = isBlob(img);
            var url = imgIsBlob ? createObjectURL(img) : img;
            var image = new Image();
            if (!imgIsBlob) {
                image.crossOrigin = 'anonymous';
            }
            image.onload = function () {
                resolve(image);
            };
            image.onerror = function (err) {
                if (imgIsBlob) {
                    revokeObjectURL(url);
                }
                console.error("[loadImage] The image load failed, '".concat(img, "'."));
                reject(err);
            };
            image.src = url;
        });
    }

    function loadImageWithBlob(img, ajaxOptions) {
        return getFileBlob(img, ajaxOptions).then(function (blob) {
            return loadImage(blob).then(function (image) {
                return { blob: blob, image: image };
            });
        });
    }

    function canvasToBlob(canvas, type, quality) {
        return new Promise(function (resolve) {
            canvas.toBlob(function (blob) {
                resolve(blob);
            }, type, quality);
        });
    }
    var compressImage = function (img, options) {
        if (options === void 0) { options = {}; }
        return new Promise(function (resolve, reject) {
            var width = options.width, height = options.height, rotate = options.rotate, _a = options.offset, offset = _a === void 0 ? [0, 0] : _a, _b = options.background, background = _b === void 0 ? '#fff' : _b, canvasWidth = options.canvasWidth, canvasHeight = options.canvasHeight, _c = options.format, format = _c === void 0 ? 'blob' : _c, _d = options.type, type = _d === void 0 ? 'image/jpeg' : _d, _e = options.quality, quality = _e === void 0 ? 0.8 : _e, beforeCompress = options.beforeCompress, beforeDraw = options.beforeDraw, afterDraw = options.afterDraw, ajaxOptions = options.ajaxOptions;
            loadImageWithBlob(img, ajaxOptions)
                .then(function (_a) {
                var image = _a.image, blob = _a.blob;
                var numWidth = toNumber(width);
                var numHeight = toNumber(height);
                var numQuality = toNumber(quality);
                if (numWidth) {
                    image.width = numWidth;
                }
                if (numHeight) {
                    image.height = numHeight;
                }
                beforeCompress === null || beforeCompress === void 0 ? void 0 : beforeCompress({ image: image, blob: blob }, options);
                var canvas = document.createElement('canvas');
                var ctx = canvas.getContext('2d');
                var info = { image: image, blob: blob, canvas: canvas, context: ctx };
                var numCanvasWidth = toNumber(typeof canvasWidth === 'function' ? canvasWidth(info, options) : canvasWidth);
                var numCanvasHeight = toNumber(typeof canvasHeight === 'function' ? canvasHeight(info, options) : canvasHeight);
                canvas.width = numCanvasWidth || image.width;
                canvas.height = numCanvasHeight || image.height;
                var bgIsTransparent = background === 'none' || background === 'transparent';
                if (bgIsTransparent) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                else {
                    ctx.fillStyle = background;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                var internalOffset = [0, 0];
                if (rotate !== nativeUndefined) {
                    ctx.translate(image.width / 2, image.height / 2);
                    internalOffset = [-image.width / 2, -image.height / 2];
                    ctx.rotate((rotate * Math.PI) / 180);
                }
                var outOffset = typeof offset === 'function' ? offset(info, options) : offset;
                beforeDraw === null || beforeDraw === void 0 ? void 0 : beforeDraw(info, options);
                var dx = internalOffset[0] + toNumber(outOffset[0]);
                var dy = internalOffset[1] + toNumber(outOffset[1]);
                ctx.drawImage(image, dx, dy, image.width, image.height);
                if (type === 'image/png' && bgIsTransparent) {
                    ctx.globalCompositeOperation = 'destination-in';
                    ctx.drawImage(image, dx, dy, image.width, image.height);
                }
                afterDraw === null || afterDraw === void 0 ? void 0 : afterDraw(info, options);
                if (format === 'blob') {
                    canvasToBlob(canvas, type, numQuality).then(resolve).catch(reject);
                }
                else {
                    resolve(canvas.toDataURL(type, numQuality));
                }
            })
                .catch(reject);
        });
    };

    function dataURLToBlob(data) {
        var parts = data.split(',');
        var meta = parts[0].substring(5).split(';');
        var type = meta[0];
        var decoder = meta.indexOf('base64') !== -1 ? atob : decodeURIComponent;
        var bstr = decoder(parts[1]);
        var n = bstr.length;
        var u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], { type: type });
    }

    function saver(blobUrl, fileName) {
        if (fileName === void 0) { fileName = ''; }
        var anchor = document.createElement('a');
        anchor.href = blobUrl;
        anchor.style.display = 'none';
        anchor.setAttribute('download', fileName);
        function handleClick(e) {
            e.stopPropagation();
            anchor.removeEventListener('click', handleClick);
        }
        anchor.addEventListener('click', handleClick);
        document.body.appendChild(anchor);
        anchor.click();
        document.body.removeChild(anchor);
    }
    function download(data, options) {
        return __awaiter(this, void 0, void 0, function () {
            var config, fileName, type, dataType, transformRequest, transformResponse, payload, asyncTransformRequest, asyncTransformResponse, ajaxOptions, ev, res, currentFileName, url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        config = typeof options === 'object' ? options : {};
                        if (typeof options === 'string') {
                            config.fileName = options;
                        }
                        fileName = config.fileName, type = config.type, dataType = config.dataType, transformRequest = config.transformRequest, transformResponse = config.transformResponse;
                        if (!(typeof data === 'string')) return [3, 8];
                        if (!(!dataType && /^blob:.*?\/.*/.test(data))) return [3, 1];
                        saver(data, fileName);
                        return [2, Promise.resolve()];
                    case 1:
                        if (!(!dataType && /^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(data))) return [3, 2];
                        payload = dataURLToBlob(data);
                        return [3, 7];
                    case 2:
                        if (!(dataType === 'url' || (!dataType && isUrl(data)))) return [3, 6];
                        asyncTransformRequest = function (opts) {
                            var tempOptions = typeof transformRequest === 'function' ? transformRequest(opts) : opts;
                            return isPromiseLike(tempOptions) ? tempOptions : Promise.resolve(tempOptions);
                        };
                        asyncTransformResponse = function (res) {
                            var tempRes = typeof transformResponse === 'function' ? transformResponse(res) : res;
                            return isPromiseLike(tempRes) ? tempRes : Promise.resolve(tempRes);
                        };
                        return [4, asyncTransformRequest({ responseType: 'blob' })];
                    case 3:
                        ajaxOptions = _a.sent();
                        return [4, ajax(data, ajaxOptions)];
                    case 4:
                        ev = _a.sent();
                        return [4, asyncTransformResponse(ev.target.response)];
                    case 5:
                        res = _a.sent();
                        currentFileName = fileName || data.split('?')[0].split('#')[0].split('/').pop();
                        return [2, download(res, { fileName: currentFileName, type: type || (isBlob(res) ? res.type : nativeUndefined) })];
                    case 6:
                        payload = new Blob([data], { type: type || 'text/plain' });
                        _a.label = 7;
                    case 7: return [3, 9];
                    case 8:
                        if (data instanceof Blob) {
                            payload = data;
                        }
                        _a.label = 9;
                    case 9:
                        if (!payload) {
                            payload = new Blob([data], { type: type });
                        }
                        if (navigator.msSaveBlob) {
                            navigator.msSaveBlob(payload, fileName || 'download');
                        }
                        else {
                            url = createObjectURL(payload);
                            saver(url, fileName);
                            revokeObjectURL(url);
                        }
                        return [2, Promise.resolve()];
                }
            });
        });
    }

    var FileReaderMethodMap = {
        arrayBuffer: 'readAsArrayBuffer',
        binaryString: 'readAsBinaryString',
        dataURL: 'readAsDataURL',
        text: 'readAsText'
    };
    var fileReader = function (blob, type) {
        if (type === void 0) { type = 'dataURL'; }
        var method = FileReaderMethodMap[type];
        if (!method) {
            method = FileReaderMethodMap.dataURL;
        }
        return new Promise(function (resolve, reject) {
            var reader = new FileReader();
            reader[method](blob);
            reader.onload = function () { return resolve(reader.result); };
            reader.onerror = function (error) { return reject(error); };
        });
    };

    var config = {
        image: 'image/*,.jpeg,.jpg,.gif,.bmp,.png,.webp,.svg,.apng,.avif,.ico,.tif,.tiff',
        audio: 'audio/*,.mp3,.wav,.aac,.flac',
        video: 'video/*,.mp4,.webm,.ogg,.mov',
        pdf: 'application/pdf,.pdf',
        word: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document,.doc,.docx',
        excel: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel,.xls,.xlsx'
    };
    function getFileType(file) {
        var type;
        if (isBlob(file) || isUploadFile(file)) {
            forEach(config, function (accept, fileType) {
                if (checkFileType(file, accept)) {
                    type = fileType;
                    return false;
                }
            });
        }
        return type;
    }

    function calcContrast(w, h) {
        var n = gcd(w, h);
        return "".concat(divide(round(w), n), ":").concat(divide(round(h), n));
    }
    function getImageInfo(img, ajaxOptions) {
        return loadImageWithBlob(img, ajaxOptions).then(function (_a) {
            var image = _a.image, blob = _a.blob;
            var width = image.width, height = image.height;
            return {
                width: width,
                height: height,
                contrast: calcContrast(width, height),
                measure: "".concat(width, " \u00D7 ").concat(height, " px"),
                size: bytesToSize(blob.size),
                bytes: blob.size,
                image: image,
                blob: blob
            };
        });
    }

    var mimeTypes = [
        ['text/plain', ['txt']],
        ['text/css', ['css']],
        ['text/html', ['htm', 'html']],
        ['text/javascript', ['js', 'mjs']],
        ['text/csv', ['csv']],
        ['text/markdown', ['md', 'markdown']],
        ['image/gif', ['gif']],
        ['image/jpeg', ['jpg', 'jpeg', 'jfif', 'pjpeg', 'pjp']],
        ['image/png', ['png']],
        ['image/svg+xml', ['svg']],
        ['image/webp', ['webp']],
        ['image/apng', ['apng']],
        ['image/avif', ['avif']],
        ['image/bmp', ['bmp']],
        ['image/x-icon', ['ico', 'cur']],
        ['image/tiff', ['tif', 'tiff']],
        ['application/xml', ['xml']],
        ['application/zip', ['zip']],
        ['application/pdf', ['pdf']],
        ['application/json', ['json']],
        ['application/yaml', ['yaml', 'yml']],
        ['application/vnd.openxmlformats-officedocument.wordprocessingml.document', ['doc', 'docx']],
        ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', ['xls', 'xlsx']],
        ['audio/mp3', ['mp3']],
        ['audio/wav', ['wav']],
        ['audio/aac', ['aac']],
        ['audio/flac', ['flac']],
        ['video/mp4', ['mp4']],
        ['video/ogg', ['ogg']],
        ['video/webm', ['webm']],
        ['video/quicktime', ['mov']]
    ];
    function getMimeType(fileName) {
        var _a;
        var ext = getExtname(fileName).slice(1).toLowerCase();
        return ext ? (_a = mimeTypes.find(function (item) { return item[1].includes(ext); })) === null || _a === void 0 ? void 0 : _a[0] : nativeUndefined;
    }

    function injectStyle(css, options) {
        var _a = options || {}, _b = _a.container, container = _b === void 0 ? document.head || document.getElementsByTagName('head')[0] || document.body : _b, _c = _a.insertAt, insertAt = _c === void 0 ? 'top' : _c, onBefore = _a.onBefore;
        var style = document.createElement('style');
        if (style.styleSheet) {
            style.styleSheet.cssText = css;
        }
        else {
            style.appendChild(document.createTextNode(css));
        }
        if (typeof onBefore === 'function') {
            onBefore(style);
        }
        var atTop = insertAt === 'top';
        if (atTop && container.prepend) {
            container.prepend(style);
        }
        else if (atTop && container.firstChild) {
            container.insertBefore(style, container.firstChild);
        }
        else {
            container.appendChild(style);
        }
        return style;
    }

    function loadScript(src, options) {
        return new Promise(function (resolve, reject) {
            var container = document.head || document.getElementsByTagName('head')[0] || document.body;
            var script = document.createElement('script');
            var _a = options || {}, attrs = _a.attrs, _b = _a.destroyOnError, destroyOnError = _b === void 0 ? true : _b, restOptions = __rest(_a, ["attrs", "destroyOnError"]);
            var props = __assign(__assign({ async: true, type: 'text/javascript' }, restOptions), { src: src });
            for (var key in props) {
                if (key === 'onload' || key === 'onerror') {
                    continue;
                }
                script[key] = props[key];
            }
            if (typeof attrs === 'object') {
                objectKeys(attrs).forEach(function (key) {
                    script.setAttribute(key, attrs[key]);
                });
            }
            script.onload = function (ev) {
                var _a;
                this.onerror = this.onload = null;
                (_a = props.onload) === null || _a === void 0 ? void 0 : _a.call(this, ev);
                resolve(script);
            };
            script.onerror = function (ev) {
                var _a;
                this.onerror = this.onload = null;
                (_a = props.onerror) === null || _a === void 0 ? void 0 : _a.call(this, ev);
                if (destroyOnError) {
                    container.removeChild(script);
                }
                reject(new URIError('Failed to load ' + this.src));
            };
            container.appendChild(script);
        });
    }

    function calculateCursorPosition(prevPos, prevCtrlValue, rawValue, ctrlValue, options) {
        if (options === void 0) { options = {}; }
        var _a = options.placeholderChar, placeholderChar = _a === void 0 ? ' ' : _a, _b = options.maskReg, maskReg = _b === void 0 ? /\D/g : _b, type = options.type;
        var realCtrlValue = toString(prevCtrlValue);
        var realRawValue = toString(rawValue);
        var placeholderChars = isArray(placeholderChar) ? placeholderChar : [placeholderChar];
        var editLength = realRawValue.length - realCtrlValue.length;
        var isAddition = editLength > 0;
        var pos = prevPos;
        if (isAddition) {
            var additionStr = realRawValue.substring(pos - editLength, pos);
            var ctrlCharCount = additionStr.replace(maskReg, '').length;
            pos -= editLength - ctrlCharCount;
            var placeholderCharCount = 0;
            while (ctrlCharCount > 0) {
                if (placeholderChars.indexOf(ctrlValue.charAt(pos - ctrlCharCount + placeholderCharCount)) !== -1) {
                    placeholderCharCount++;
                }
                else {
                    ctrlCharCount--;
                }
            }
            pos += placeholderCharCount;
        }
        if ((type === 'mobile' && (pos === 4 || pos === 9)) || (type === 'bankCard' && pos > 0 && pos % 5 === 0)) {
            pos -= 1;
        }
        return pos;
    }

    var letter = 'abcdefghijklmnopqrstuvwxyz';
    var chars = {
        number: '0123456789',
        lower: letter,
        upper: letter.toUpperCase()
    };
    var allChars = chars.number + chars.lower + chars.upper;
    function internalRandomString(len, pool, prefix) {
        if (prefix === void 0) { prefix = ''; }
        while (len-- > 0) {
            var r = pool[randomInt(0, pool.length - 1)];
            return internalRandomString(len, pool, prefix + r);
        }
        return prefix;
    }
    var randomString$1 = function (len, pool) {
        if (len === void 0) { len = 0; }
        var _pool;
        if (typeof pool !== 'string') {
            _pool = allChars;
        }
        else if (chars[pool]) {
            _pool = chars[pool];
        }
        else {
            _pool = pool;
        }
        return internalRandomString(toNumber(len), _pool);
    };

    function strlen(str) {
        var realStr = toString(str);
        var len = 0;
        for (var i = 0; i < realStr.length; i++) {
            var c = realStr.charCodeAt(i);
            if ((c >= 0x0001 && c <= 0x007e) || (0xff60 <= c && c <= 0xff9f)) {
                len++;
            }
            else {
                len += 2;
            }
        }
        return len;
    }

    function transformFieldNames(data, fieldNames, childrenField, nodeAssign) {
        if (nodeAssign === void 0) { nodeAssign = 'spread'; }
        if (!isArray(data)) {
            return data;
        }
        if (data.length <= 0) {
            return [];
        }
        function recusion(arr) {
            return arr.map(function (item) {
                if (!isObject(item)) {
                    return item;
                }
                var newItem = nodeAssign === 'spread' ? __assign({}, item) : item;
                var delKeys = [];
                if (childrenField && isArray(newItem[childrenField]) && newItem[childrenField].length > 0) {
                    newItem[childrenField] = recusion(newItem[childrenField].slice());
                }
                var newKeys = objectKeys(fieldNames);
                newKeys.forEach(function (newKey) {
                    var oldKey = fieldNames[newKey];
                    if (oldKey in newItem) {
                        newItem[newKey] = newItem[oldKey];
                        if (newKeys.indexOf(oldKey) === -1) {
                            delKeys.push(oldKey);
                        }
                    }
                });
                if (delKeys.length > 0) {
                    delKeys.forEach(function (delKey) {
                        delete newItem[delKey];
                    });
                }
                return newItem;
            });
        }
        return recusion(data.slice());
    }

    function processEmptyChildren(arr, options) {
        var _a = options.childrenField, childrenField = _a === void 0 ? 'children' : _a, _b = options.emptyChildrenValue, emptyChildrenValue = _b === void 0 ? 'none' : _b;
        arr.forEach(function (item) {
            if (item[childrenField].length <= 0) {
                if (emptyChildrenValue === 'null') {
                    item[childrenField] = null;
                }
                else {
                    delete item[childrenField];
                }
            }
            else {
                processEmptyChildren(item[childrenField], options);
            }
        });
    }
    function listToTree(list, options) {
        if (options === void 0) { options = {}; }
        var _a = options.keyField, keyField = _a === void 0 ? 'id' : _a, _b = options.parentField, parentField = _b === void 0 ? 'pid' : _b, _c = options.childrenField, childrenField = _c === void 0 ? 'children' : _c, _d = options.emptyChildrenValue, emptyChildrenValue = _d === void 0 ? 'none' : _d, _e = options.nodeAssign, nodeAssign = _e === void 0 ? 'spread' : _e;
        var tree = [];
        var record = {};
        if (!isArray(list)) {
            return tree;
        }
        list.forEach(function (item) {
            if (isObject(item)) {
                var newItem = nodeAssign === 'spread' ? __assign({}, item) : item;
                var id = newItem[keyField];
                var pid = newItem[parentField];
                if (record[id]) {
                    newItem[childrenField] = record[id];
                }
                else {
                    newItem[childrenField] = record[id] = [];
                }
                if (pid) {
                    if (!record[pid]) {
                        record[pid] = [newItem];
                    }
                    else {
                        record[pid].push(newItem);
                    }
                }
                else {
                    tree.push(newItem);
                }
            }
        });
        if (emptyChildrenValue !== 'array') {
            processEmptyChildren(tree, options);
        }
        return tree;
    }

    function treeToList(tree, childrenField) {
        var list = [];
        if (!isArray(tree)) {
            return list;
        }
        function recusion(arr) {
            arr.forEach(function (item) {
                if (isObject(item)) {
                    var newItem = __assign({}, item);
                    list.push(newItem);
                    if (newItem[childrenField]) {
                        if (isArray(newItem[childrenField]) && newItem[childrenField].length > 0) {
                            recusion(newItem[childrenField]);
                        }
                        delete newItem[childrenField];
                    }
                }
                else {
                    list.push(item);
                }
            });
        }
        recusion(tree);
        return list;
    }

    function filterTree(tree, predicate, childrenField, nodeAssign) {
        if (childrenField === void 0) { childrenField = 'children'; }
        if (nodeAssign === void 0) { nodeAssign = 'spread'; }
        var result = [];
        if (!isArray(tree)) {
            return result;
        }
        tree.forEach(function (item) {
            var newItem = item;
            if (isObject(item)) {
                newItem = nodeAssign === 'spread' ? __assign({}, item) : item;
            }
            if (predicate(newItem)) {
                if (isObject(newItem)) {
                    var childs = newItem[childrenField];
                    if (isArray(childs) && childs.length > 0) {
                        newItem[childrenField] = filterTree(childs, predicate, childrenField, nodeAssign);
                    }
                }
                result.push(newItem);
            }
        });
        return result;
    }

    function findTreeNode(tree, predicate, childrenField) {
        if (childrenField === void 0) { childrenField = 'children'; }
        var stack = [];
        var node;
        if (isArray(tree)) {
            forEach(tree, function (item) {
                stack.push(item);
                while (stack.length) {
                    var temp = stack.pop();
                    if (predicate(temp)) {
                        node = temp;
                        break;
                    }
                    if (isObject(temp)) {
                        var childs = temp[childrenField];
                        if (isArray(childs) && childs.length > 0) {
                            childs.forEach(function (c) {
                                stack.push(c);
                            });
                        }
                    }
                }
                if (node) {
                    return false;
                }
            });
        }
        return node;
    }

    function findTreeNodes(tree, predicate, childrenField) {
        if (childrenField === void 0) { childrenField = 'children'; }
        var stack = [];
        var nodes = [];
        if (isArray(tree)) {
            forEach(tree, function (item) {
                stack.push(item);
                while (stack.length) {
                    var temp = stack.pop();
                    if (predicate(temp)) {
                        nodes.push(temp);
                    }
                    if (isObject(temp)) {
                        var childs = temp[childrenField];
                        if (isArray(childs) && childs.length > 0) {
                            childs.forEach(function (c) {
                                stack.push(c);
                            });
                        }
                    }
                }
            });
        }
        return nodes;
    }

    function internalFindTreeSelect(tree, predicate, childrenField, path) {
        if (path === void 0) { path = []; }
        var result = [];
        if (isArray(tree)) {
            forEach(tree, function (item) {
                path.push(item);
                if (predicate(item)) {
                    result = path;
                    return false;
                }
                if (isObject(item)) {
                    var childs = item[childrenField];
                    if (isArray(childs) && childs.length > 0) {
                        var findChildren = internalFindTreeSelect(childs, predicate, childrenField, path);
                        if (findChildren.length > 0) {
                            result = findChildren;
                            return false;
                        }
                    }
                }
                path.pop();
            });
        }
        return result;
    }
    function findTreeSelect(tree, predicate, childrenField) {
        if (childrenField === void 0) { childrenField = 'children'; }
        return internalFindTreeSelect(tree, predicate, childrenField);
    }

    var VERSION = "5.5.0";

    /**
     * 事件触发器，支持浏览器端和 node 端。
     *
     * @class
     * @example
     *
     * const emitter = new Emitter();
     *
     * // 注册监听方法
     * emitter.on('foo', () => console.log('foo 1'));
     * emitter.on('foo', () => console.log('foo 2'));
     *
     * // 触发方法
     * emitter.emit('foo');
     * // foo 1
     * // foo 2
     *
     * // 取消监听方法
     * emitter.off('foo');
     *
     * // 支持链式调用
     * emitter.on('foo', () => {})
     *  .on('foo', () => {})
     *  .off('foo');
     */
    var EmitterPro = /** @class */ (function () {
        function EmitterPro() {
            this.handlers = {};
        }
        /**
         * 获取全部事件名称。
         *
         * @returns 事件名称数组。
         * @example
         * emitter.on('foo', () => {});
         * emitter.on('bar', () => {});
         *
         * emitter.eventNames(); // ['foo', 'bar']
         */
        EmitterPro.prototype.eventNames = function () {
            var _a;
            var symbols = ((_a = Object.getOwnPropertySymbols) === null || _a === void 0 ? void 0 : _a.call(Object, this.handlers)) || [];
            var keys = Object.keys(this.handlers);
            return keys.concat(symbols);
        };
        /**
         * 获取事件名称的全部监听方法（原始方法，未经过包装处理）。
         *
         * @param eventName 事件名称
         * @returns 对应事件名称的监听方法数组
         * @example
         * const fn1 = () => console.log('bar');
         * const fn2 = () => console.log('baz');
         *
         * emitter.on('test', fn1);
         * emitter.once('test', fn2);
         *
         * emitter.rawListeners('test'); // [fn1, fn2]
         */
        EmitterPro.prototype.rawListeners = function (eventName) {
            var handler = this.handlers[eventName];
            return handler ? handler.map(function (item) { return item.raw; }) : [];
        };
        /**
         * 获取事件名称的全部监听方法（如通过 `once` 方法注册，返回的是包装方法）。
         *
         * @param eventName 事件名称
         * @returns 对应事件名称的监听方法数组
         * @example
         * const fn1 = () => console.log('bar');
         * const fn2 = () => console.log('baz');
         *
         * emitter.on('test', fn1);
         * emitter.once('test', fn2);
         *
         * emitter.rawListeners('test'); // [fn1, wrapFn2]
         */
        EmitterPro.prototype.listeners = function (eventName) {
            var handler = this.handlers[eventName];
            return handler ? handler.map(function (item) { return item.wrap; }) : [];
        };
        /**
         * 判断事件名称对应的监听方法是否存在。
         *
         * @param eventName 事件名称
         * @param listener 监听方法
         * @returns 如果事件名称存在该事件方法返回 `true`，否则返回 `false`。
         * @example
         * const fn1 = () => console.log('bar');
         * const fn2 = () => console.log('baz');
         *
         * emitter.on('test', fn1);
         * emitter.once('test', fn2);
         *
         * emitter.hasListener('test', fn1); // true
         * emitter.hasListener('test', fn2); // true
         *
         * // fn2 是通过 once 方法注册，执行一次后自动解绑
         * emitter.emit('test');
         *
         * emitter.hasListener('test', fn1); // true
         * emitter.hasListener('test', fn2); // false
         */
        EmitterPro.prototype.hasListener = function (eventName, listener) {
            return this.rawListeners(eventName).some(function (item) { return item === listener; });
        };
        EmitterPro.prototype._on = function (eventName, raw, wrap, context, dir) {
            if (context === void 0) { context = null; }
            if (dir === void 0) { dir = 1; }
            var currentListener = { raw: raw, wrap: wrap, context: context };
            if (!this.handlers[eventName]) {
                this.handlers[eventName] = [currentListener];
            }
            else {
                var appendMethod = dir === 1 ? 'push' : 'unshift';
                this.handlers[eventName][appendMethod](currentListener);
            }
            return this;
        };
        /**
         * 注册监听方法。同 `on` 方法，只是将监听方法添加到最前面（事件触发是按顺序执行）。
         *
         * @param eventName 事件名称
         * @param listener 监听方法
         * @param context 执行上下文
         * @returns 事件触发器实例。
         * @example
         * emitter.on('foo', () => console.log('bar'));
         * emitter.prependListener('foo', () => console.log(42));
         *
         * emitter.emit('foo');
         * // 42
         * // bar
         */
        EmitterPro.prototype.prependListener = function (eventName, listener, context) {
            return this._on(eventName, listener, listener, context, 0);
        };
        /**
         * 注册监听方法。允许多次添加同一引用的函数。
         *
         * @param eventName 事件名称
         * @param listener 监听方法
         * @param context 执行上下文
         * @returns 事件触发器实例。
         * @example
         * emitter.on('foo', () => console.log('bar'));
         * emitter.on('foo', () => console.log(42));
         *
         * emitter.emit('foo');
         * // bar
         * // 42
         */
        EmitterPro.prototype.on = function (eventName, listener, context) {
            return this._on(eventName, listener, listener, context);
        };
        EmitterPro.prototype._wrapOnce = function (eventName, listener, context) {
            var _this = this;
            if (context === void 0) { context = null; }
            var wrap = (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                listener.apply(context, args);
                _this.off(eventName, wrap);
            });
            return wrap;
        };
        /**
         * 仅触发一次的监听方法。使用方法同 `on` 。
         *
         * @param eventName 事件名称
         * @param listener 监听方法
         * @param context 执行上下文
         * @returns 事件触发器实例。
         * @example
         * emitter.on('foo', () => console.log('bar'));
         * emitter.once('foo', () => console.log(42));
         *
         * emitter.emit('foo');
         * // bar
         * // 42
         *
         * emitter.emit('foo');
         * // bar
         */
        EmitterPro.prototype.once = function (eventName, listener, context) {
            var wrap = this._wrapOnce(eventName, listener, context);
            return this._on(eventName, listener, wrap, context);
        };
        /**
         * 仅触发一次的监听方法。同 `once` 方法，只是添加到最前面（事件触发是按顺序执行）。
         *
         * @param eventName 事件名称
         * @param listener 监听方法
         * @param context 执行上下文
         * @returns 事件触发器实例。
         * @example
         * emitter.on('foo', () => console.log('bar'));
         * emitter.prependOnceListener('foo', () => console.log(42));
         *
         * emitter.emit('foo');
         * // 42
         * // bar
         *
         * emitter.emit('foo');
         * // bar
         */
        EmitterPro.prototype.prependOnceListener = function (eventName, listener, context) {
            var wrap = this._wrapOnce(eventName, listener, context);
            return this._on(eventName, listener, wrap, context, 0);
        };
        /**
         * 取消监听方法。如果不传第二个参数，将取消该事件名称的全部监听方法。如果多次添加同一引用的函数，需要多次删除。
         *
         * @param eventName 事件名称
         * @param listener 监听方法
         * @returns 事件触发器实例。
         * @example
         * const fn = () => console.log('bar');
         * emitter.on('foo', fn);
         * emitter.on('foo', () => console.log('baz'));
         * emitter.on('foo', () => console.log(42));
         *
         * emitter.emit('foo');
         * // bar
         * // baz
         * // 42
         *
         * emitter.off('foo', fn); // 取消 foo 的监听方法 fn
         *
         * emitter.emit('foo');
         * // bar
         * // 42
         *
         * emitter.off('foo'); // 取消 foo 的全部监听方法
         * emitter.emit('foo'); // 什么都没发生
         */
        EmitterPro.prototype.off = function (eventName, listener) {
            var handler = this.handlers[eventName];
            if (handler) {
                if (listener) {
                    var index = handler.findIndex(function (item) { return item.wrap === listener || item.raw === listener; });
                    if (index !== -1) {
                        handler.splice(index, 1);
                    }
                }
                else {
                    delete this.handlers[eventName];
                }
            }
            return this;
        };
        /**
         * 取消全部事件名称的监听方法。
         *
         * @returns 事件触发器实例。
         * @example
         * const fn = () => console.log('bar');
         * emitter.on('test', fn);
         * emitter.on('test', () => console.log('baz'));
         * emitter.on('test', () => console.log(42));
         *
         * emitter.on('other', fn);
         * emitter.on('other', () => console.log('baz'));
         *
         * emitter.emit('test');
         * // bar
         * // baz
         * // 42
         *
         * emitter.emit('other');
         * // bar
         * // baz
         *
         * emitter.offAll(); // 取消全部监听方法
         *
         * emitter.emit('test'); // 什么都没发生
         * emitter.emit('other'); // 什么都没发生
         */
        EmitterPro.prototype.offAll = function () {
            this.handlers = {};
            return this;
        };
        /**
         * 触发监听方法。
         *
         * @param eventName 事件名称
         * @param args 触发监听方法的参数（从第二个参数开始都将传给监听方法）
         * @returns 如果触发成功返回 `true`，否则返回 `false`。
         * @example
         * emitter.on('foo', () => console.log('bar'));
         * emitter.on('foo', () => console.log(42));
         *
         * emitter.emit('foo');
         * // bar
         * // 42
         *
         * // 支持传入参数
         * emitter.on('test' (a, b) => console.log(a + b));
         * emitter.on('test' (a, b) => console.log(a * b));
         *
         * emitter.emit('other', 2, 5);
         * // 7
         * // 10
         *
         * emitter.emit('other', 5, 5);
         * // 10
         * // 25
         */
        EmitterPro.prototype.emit = function (eventName) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var handler = this.handlers[eventName];
            if (handler && handler.length > 0) {
                handler.forEach(function (listener) {
                    listener.wrap.apply(listener.context, args);
                });
                return true;
            }
            return false;
        };
        return EmitterPro;
    }());

    var cache = {};
    var MemoryStorage = /** @class */ (function () {
        function MemoryStorage(scope) {
            if (scope === void 0) { scope = 'default'; }
            this.scope = scope;
            if (!cache[this.scope]) {
                cache[this.scope] = {};
            }
            this.data = cache[this.scope];
        }
        MemoryStorage.prototype.getItem = function (key) {
            return key in this.data ? this.data[key] : null;
        };
        MemoryStorage.prototype.setItem = function (key, value) {
            this.data[key] = value;
        };
        MemoryStorage.prototype.removeItem = function (key) {
            delete this.data[key];
        };
        MemoryStorage.prototype.clear = function () {
            cache[this.scope] = {};
            this.data = cache[this.scope];
        };
        return MemoryStorage;
    }());

    // 随机字符串
    function randomString() {
        return Math.random().toString(16).substring(2, 8);
    }
    // 是否支持 storage
    function isStorageSupported(storage) {
        try {
            var isSupport = typeof storage === 'object' &&
                storage !== null &&
                !!storage.setItem &&
                !!storage.getItem &&
                !!storage.removeItem;
            if (isSupport) {
                var key = randomString() + new Date().getTime();
                var value = '1';
                storage.setItem(key, value);
                if (storage.getItem(key) !== value) {
                    return false;
                }
                storage.removeItem(key);
            }
            return isSupport;
        }
        catch (e) {
            console.error("[cache2] ".concat(storage, " is not supported. The default memory cache will be used."));
            return false;
        }
    }
    function parse(value, reviver) {
        try {
            return JSON.parse(value, reviver);
        }
        catch (e) {
            return value;
        }
    }
    function stringify(value, replacer) {
        return JSON.stringify(value, replacer);
    }

    /**
     * 数据存储管理。
     *
     * @class
     * @param {Object} [storage] 自定义缓存对象要包含 `getItem` `setItem` `removeItem` 方法。默认使用内存缓存。
     * @param {Object} [options] 配置项。可选。
     * @param {boolean} [options.needParsed] 存取数据时是否需要序列化和解析数据。如果使用内置的内存缓存，默认 `false`，如果自定义 `storage` 默认 `true`。
     * @param {Function} [options.replacer] 数据存储时序列化的参数，透传给 [JSON.stringify](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) 的 `replacer` 参数。仅在 `needParsed=true` 时生效。
     * @param {Function} [options.reviver] 数据获取时转换的参数，透传给 [JSON.parse](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse) 的 `reviver` 参数。仅在 `needParsed=true` 时生效。
     * @param {string} [options.prefix] 缓存键前缀。便于管理同域名下的不同项目缓存。
     * @example
     * // 使用内存缓存
     * const memory = new Storage();
     * memory.set('foo', { baz: 42 });
     * memory.get('foo');
     * // { baz: 42 }
     *
     * // 自定义缓存 sessionStorage 。
     * const session = new Storage(window.sessionStorage);
     * session.set('foo', { a: 1, b: ['bar'], c: ['x', 2, 3] });
     * session.get('foo');
     * // { a: 1, b: ['bar'], c: ['x', 2, 3] }
     *
     * session.del('foo'); // 删除缓存
     * session.get('foo');
     * // null
     *
     * // 使用缓存键前缀。
     * // 如果要使用内存缓存， storage 传 `undefined`。
     * const local = new Storage(window.localStorage, { prefix: 'project_name' });
     * local.set('foo', { baz: 42 });
     * local.get('foo');
     * // { baz: 42 }
     */
    var Storage = /** @class */ (function () {
        function Storage(storage, options) {
            if (options === void 0) { options = {}; }
            var isSupported = storage ? isStorageSupported(storage) : false;
            this.options = __assign({ needParsed: isSupported, prefix: '' }, options);
            this.storage = isSupported ? storage : new MemoryStorage(this.options.memoryScope);
        }
        /**
         * 内部用于获取存储的键名称。
         *
         * 如果实例有设置 `prefix`，返回 `prefix + key`。
         *
         * @protected
         * @param key 原键名称
         * @returns 存储的键名称
         */
        Storage.prototype.getKey = function (key) {
            return this.options.prefix + key;
        };
        /**
         * 获取存储的数据。
         *
         * @param {string} key 键名称。
         * @returns 如果键值存在返回键值，否则返回 `null`。
         * @example
         * const local = new Storage(window.localStorage);
         * local.set('foo', { baz: 42 });
         * local.get('foo');
         * // { baz: 42 }
         */
        Storage.prototype.get = function (key) {
            var value = this.storage.getItem(this.getKey(key));
            return this.options.needParsed ? parse(value, this.options.reviver) : value;
        };
        /**
         * 存储数据。
         *
         * @param key 键名称。
         * @param value 键值。
         * @example
         * const local = new Storage(window.localStorage);
         * local.set('foo', { baz: 42 });
         * local.get('foo');
         * // { baz: 42 }
         */
        Storage.prototype.set = function (key, value) {
            this.storage.setItem(this.getKey(key), this.options.needParsed ? stringify(value, this.options.replacer) : value);
        };
        /**
         * 删除存储的数据。
         *
         * @param key 键名称。
         * @example
         * const local = new Storage(window.localStorage);
         * local.set('foo', { baz: 42 });
         * local.get('foo');
         * // { baz: 42 }
         *
         * local.del('foo');
         * local.get('foo');
         * // null
         */
        Storage.prototype.del = function (key) {
            this.storage.removeItem(this.getKey(key));
        };
        /**
         * 清除存储的所有键。
         *
         * 注意：该方法调用 `storage.clear()`，可能会将同域下的不同实例的所有键都清除。如果要避免这种情况，建议使用 `import { Cache } 'cache2'`。
         *
         * @example
         * const local = new Storage(window.localStorage);
         * local.set('foo', { baz: 42 });
         * local.get('foo');
         * // { baz: 42 }
         *
         * local.clear();
         * local.get('foo');
         * // null
         */
        Storage.prototype.clear = function () {
            if (typeof this.storage.clear === 'function') {
                this.storage.clear();
            }
        };
        return Storage;
    }());

    // 命名空间缓存键前缀。
    var defaultPrefix = 'cache2_';
    var defaultNamespace = 'default';
    /**
     * 功能丰富的数据存储管理，支持 `自定义缓存` `命名空间` `数据过期时间` `限制缓存数量` `自定义事件`。
     *
     * 注意：如果你需要的是简单的基本数据存储管理，例如浏览器存储，建议使用 `import { Storage } from 'cache2'`。
     *
     * @class
     * @param {string} [namespace] 命名空间。可选。
     * @param {Object} [options] 配置项。可选。
     * @param {Object} [options.storage] 自定义缓存对象要包含 `getItem` `setItem` `removeItem` 方法。默认使用内置的内存缓存。
     * @param {number} [options.max=-1] 最大缓存数据数量。`-1` 表示无限制。默认 `-1`。
     * @param {'limited' | 'replaced'} [options.maxStrategy='limited'] 当达到最大缓存数量限制时的缓存策略。`limited` 表示达到限制数量后不存入数据，保存时返回 `false`。`replaced` 表示优先替换快过期的数据，如果都是一样的过期时间(0)，按照先入先出规则处理，保存时始终返回 `true`。默认 `limited`。
     * @param {number} [options.stdTTL=0] 相对当前时间的数据存活时间，应用于当前实例的所有缓存数据。单位为毫秒，`0` 表示无期限。默认 `0`。
     * @param {number} [options.checkperiod=0] 定时检查过期数据，单位毫秒。如果小于等于 `0` 表示不启动定时器检查。默认 `0`。
     * @param {boolean} [options.needParsed] 存取数据时是否需要序列化和解析数据。如果使用内置的内存缓存，默认 `false`，如果自定义 `storage` 默认 `true`。
     * @param {Function} [options.replacer] 数据存储时序列化的参数，透传给 [JSON.stringify](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) 的 `replacer` 参数。仅在 `needParsed=true` 时生效。
     * @param {Function} [options.reviver] 数据获取时转换的参数，透传给 [JSON.parse](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse) 的 `reviver` 参数。仅在 `needParsed=true` 时生效。
     * @param {string} [options.prefix] 缓存键前缀。
     * @example
     * // 自定义过期时间
     * const memoryCache = new Cache({ stdTTL: 60 * 1000 });
     * memoryCache.set('foo', { baz: 42 });
     * memoryCache.get('foo');
     * // { baz: 42 }
     *
     * // 60 seconds later
     *
     * memoryCache.get('foo');
     * // undefined
     *
     * // 命名空间、自定义缓存
     * const localCache = new Cache('namespace', { storage: window.localStorage });
     * localCache.set('foo', { baz: 42 });
     * localCache.get('foo');
     * // { baz: 42 }
     *
     * localCache.del('foo');
     * localCache.get('foo');
     * // undefined
     */
    var Cache = /** @class */ (function (_super) {
        __extends(Cache, _super);
        function Cache(namespace, options) {
            var _this = _super.call(this) || this;
            var ns = defaultNamespace, opts;
            if (typeof namespace === 'string') {
                ns = namespace || defaultNamespace;
            }
            else if (typeof namespace === 'object') {
                opts = namespace;
            }
            if (!opts && typeof options === 'object') {
                opts = options;
            }
            _this.options = __assign({ max: -1, stdTTL: 0, maxStrategy: 'limited', checkperiod: 0, prefix: defaultPrefix }, opts);
            _this.storage = new Storage(_this.options.storage, __assign({ memoryScope: ns }, _this.options));
            _this.cacheKey = ns;
            _this.startCheckperiod();
            return _this;
        }
        /**
         * 检查当前键值是否过期，如果过期将会自动删除。
         *
         * @param key 键名称。
         * @param data 缓存数据。
         * @returns 如果键值已过期返回 `false` ，否则返回 `true`。
         */
        Cache.prototype._check = function (key, data) {
            var ret = true;
            if (data.t !== 0 && data.t < Date.now()) {
                ret = false;
                this.del(key);
                this.emit('expired', key, data.v);
            }
            return ret;
        };
        Cache.prototype._wrap = function (value, ttl) {
            var now = Date.now();
            var currentTtl = typeof ttl === 'number' ? ttl : this.options.stdTTL;
            var livetime = currentTtl > 0 ? now + currentTtl : 0;
            return {
                v: value,
                t: livetime,
                n: now
            };
        };
        Cache.prototype._isLimited = function (len) {
            return this.options.max > -1 && len >= this.options.max;
        };
        Cache.prototype._getReplaceKey = function (keys, cacheValues) {
            var retkey = keys[0];
            keys.forEach(function (key) {
                if (cacheValues[key].t < cacheValues[retkey].t ||
                    (cacheValues[key].t === cacheValues[retkey].t && cacheValues[key].n < cacheValues[retkey].n)) {
                    retkey = key;
                }
            });
            return retkey;
        };
        Object.defineProperty(Cache.prototype, "cacheValues", {
            /**
             * 获取全部缓存数据，不处理过期数据和排序
             */
            get: function () {
                return this.storage.get(this.cacheKey) || {};
            },
            enumerable: false,
            configurable: true
        });
        // 设置缓存数据
        Cache.prototype.setCacheValues = function (values) {
            this.storage.set(this.cacheKey, values);
        };
        /**
         * 获取缓存值。
         *
         * @param {string} key 键名称。
         * @returns {*} 如果找到该值，则返回该值。如果未找到或已过期，则返回 `undefined`。
         * @example
         * myCache.set('myKey', obj, 5 * 60 * 1000);
         * myCache.get('myKey');
         * // { foo: 'bar', baz: 42 }
         *
         * myCache.get('myKey2');
         * // undefined
         */
        Cache.prototype.get = function (key) {
            var data = this.cacheValues[key];
            if (data && this._check(key, data)) {
                return data.v;
            }
            return;
        };
        /**
         * 获取多个缓存值。
         *
         * @param {string[]} keys 多个键名称。
         * @returns {Object} 如果找到对应键名的值，返回一个具有键值对的对象。如果未找到或已过期，则返回一个空对象 `{}`。
         * @example
         * myCache.mset([
         *   { key: 'myKey', value: { foo: 'bar', baz: 42 }, ttl: 5 * 60 * 1000 },
         *   { key: 'myKey2', value: { a: 1, b: 2 } },
         *   { key: 'myKey3', value: 'abc' }
         * ]);
         *
         * myCache.mget(['myKey', 'myKey2']);
         * // {
         * //   myKey: { foo: 'bar', baz: 42 },
         * //   myKey2: { a: 1, b: 2 }
         * // }
         */
        Cache.prototype.mget = function (keys) {
            var _this = this;
            var ret = {};
            if (!Array.isArray(keys)) {
                return ret;
            }
            var cacheValues = this.cacheValues;
            keys.forEach(function (key) {
                var data = cacheValues[key];
                if (data && _this._check(key, data)) {
                    ret[key] = data.v;
                }
            });
            return ret;
        };
        /**
         * 获取全部缓存值。
         *
         * @returns {Object} 返回一个具有键值对的对象。
         * @example
         * myCache.mset([
         *   { key: 'myKey', value: { foo: 'bar', baz: 42 }, ttl: 5 * 60 * 1000 },
         *   { key: 'myKey2', value: { a: 1, b: 2 } },
         *   { key: 'myKey3', value: 'abc' }
         * ]);
         *
         * myCache.getAll();
         * // {
         * //   myKey: { foo: 'bar', baz: 42 },
         * //   myKey2: { a: 1, b: 2 }
         * //   myKey3: 'abc'
         * // }
         */
        Cache.prototype.getAll = function () {
            var keys = Object.keys(this.cacheValues);
            return this.mget(keys);
        };
        /**
         * 设置缓存数据。
         *
         * 如果超出缓存数量，可能会设置失败。
         *
         * @param {string} key 键名称。
         * @param {*} value 键值。
         * @param {number} [ttl] 数据存活时间。单位毫秒 `ms`。
         * @returns {boolean} 如果设置成功返回 `true`，否则返回 `false`。
         * @example
         * myCache.set('myKey', { foo: 'bar', baz: 42 }, 5 * 60 * 1000);
         * // true
         */
        Cache.prototype.set = function (key, value, ttl) {
            if (this.options.max === 0) {
                return false;
            }
            var cacheValues = this.cacheValues;
            var keys = Object.keys(cacheValues);
            // 当前不存在该键值，并且数据量超过最大限制
            if (!cacheValues[key] && this._isLimited(keys.length)) {
                var validKeys = this.keys();
                if (this._isLimited(validKeys.length)) {
                    // 如果最大限制策略是替换，将优先替换快过期的数据，如果都是一样的过期时间(0)，按照先入先出规则处理。
                    if (this.options.maxStrategy === 'replaced') {
                        var replaceKey = this._getReplaceKey(validKeys, cacheValues);
                        this.del(replaceKey);
                    }
                    else {
                        // 如果是最大限制策略是不允许添加，返回 false 。
                        return false;
                    }
                }
            }
            cacheValues[key] = this._wrap(value, ttl);
            this.setCacheValues(cacheValues);
            this.emit('set', key, cacheValues[key].v);
            return true;
        };
        /**
         * 设置多个缓存数据。
         *
         * @param {Object[]} keyValueSet 多个键值对数据。
         * @returns {boolean} 如果全部设置成功返回 `true`，否则返回 `false`。
         * @example
         * myCache.mset([
         *   { key: 'myKey', value: { foo: 'bar', baz: 42 }, ttl: 5 * 60 * 1000 },
         *   { key: 'myKey2', value: { a: 1, b: 2 } },
         *   { key: 'myKey3', value: 'abc' }
         * ]);
         * // true
         */
        Cache.prototype.mset = function (keyValueSet) {
            var _this = this;
            // 该处不使用数组 some 方法，是因为不能某个失败，而导致其他就不在更新。
            var ret = true;
            keyValueSet.forEach(function (item) {
                var itemSetResult = _this.set(item.key, item.value, item.ttl);
                if (ret && !itemSetResult) {
                    ret = false;
                }
            });
            return ret;
        };
        /**
         * 删除一个或多个键。
         *
         * @param {string|string[]} key 要删除的键名。
         * @returns {number} 返回已删除的数量。
         * @example
         * myCache.set('myKey', { foo: 'bar', baz: 42 });
         * myCache.del('myKey'); // 1
         * myCache.del('not found'); // 0
         *
         * myCache.mset([
         *   { key: 'myKey', value: { foo: 'bar', baz: 42 }, ttl: 5 * 60 * 1000 },
         *   { key: 'myKey2', value: { a: 1, b: 2 } },
         *   { key: 'myKey3', value: 'abc' }
         * ]);
         * myCache.del(['myKey', 'myKey2']); // 2
         */
        Cache.prototype.del = function (key) {
            var _this = this;
            var cacheValues = this.cacheValues;
            var count = 0;
            var keys = Array.isArray(key) ? key : [key];
            keys.forEach(function (key) {
                if (cacheValues[key]) {
                    count++;
                    var oldData = cacheValues[key];
                    delete cacheValues[key];
                    _this.emit('del', key, oldData.v);
                }
            });
            if (count > 0) {
                this.setCacheValues(cacheValues);
            }
            return count;
        };
        /**
         * 清除全部缓存的数据。
         *
         * @example
         * myCache.set('bar', 1);
         * myCache.set('foo', 2);
         * myCache.keys(); // ['bar', 'foo']
         *
         * myCache.clear();
         * myCache.keys(); // []
         */
        Cache.prototype.clear = function () {
            this.storage.del(this.cacheKey);
        };
        /**
         * 获取全部键名的数组。
         *
         * @returns {string[]} 返回全部键名的数组。
         * @example
         * myCache.set('bar', 1);
         * myCache.set('foo', 2);
         *
         * myCache.keys(); // ['bar', 'foo']
         */
        Cache.prototype.keys = function () {
            var _this = this;
            var cacheValues = this.cacheValues;
            var keys = Object.keys(cacheValues);
            return keys.filter(function (key) { return _this._check(key, cacheValues[key]); });
        };
        /**
         * 判断是否存在某个键。
         *
         * @param {string} key 键名称。
         * @returns {boolean} 如果包含该键返回 `true`，否则返回 `false`。
         * @example
         * myCache.has('foo'); // false
         *
         * myCache.set('foo', 1);
         * myCache.has('foo'); // true
         */
        Cache.prototype.has = function (key) {
            var data = this.cacheValues[key];
            return !!(data && this._check(key, data));
        };
        /**
         * 获取缓存值并从缓存中删除键。
         *
         * @param {string} key 键名称。
         * @returns {*} 如果找到该值，则返回该值，并从缓存中删除该键。如果未找到或已过期，则返回 `undefined`。
         * @example
         * myCache.set('myKey', 'myValue');
         * myCache.has('myKey'); // true
         *
         * myCache.take('myKey'); // 'myValue'
         * myCache.has('myKey'); // false
         */
        Cache.prototype.take = function (key) {
            var ret;
            var data = this.cacheValues[key];
            if (data && this._check(key, data)) {
                ret = data.v;
                this.del(key);
            }
            return ret;
        };
        /**
         * 更新缓存键值的数据存活时间。
         *
         * @param {string} key 键名称。
         * @param {number} ttl 数据存活时间。
         * @returns {boolean} 如果找到并更新成功，则返回 `true`，否则返回 `false`。
         * @example
         * myCache.set('myKey', { foo: 'bar', baz: 42 }, 5 * 60 * 1000);
         * myCache.ttl('myKey', 60 * 1000);
         * // true
         *
         * myCache.ttl('not found', 1000);
         * // false
         */
        Cache.prototype.ttl = function (key, ttl) {
            var cacheValues = this.cacheValues;
            var data = cacheValues[key];
            if (data && this._check(key, data)) {
                cacheValues[key] = this._wrap(data.v, ttl);
                return true;
            }
            return false;
        };
        /**
         * 获取某个键的过期时间戳。
         *
         * @param {string} key 键名称。
         * @returns {number | undefined} 如果未找到键或已过期，返回 `undefined`。如果 `ttl` 为 `0`，返回 `0`，否则返回一个以毫秒为单位的时间戳，表示键值将过期的时间。
         * @example
         * const myCache = new Cache({ stdTTL: 5 * 1000 });
         *
         * // 假如 Date.now() = 1673330000000
         * myCache.set('ttlKey', 'expireData');
         * myCache.set('noTtlKey', 'nonExpireData', 0);
         *
         * myCache.getTtl('ttlKey'); // 1673330005000
         * myCache.getTtl('noTtlKey'); // 0
         * myCache.getTtl('unknownKey'); // undefined
         */
        Cache.prototype.getTtl = function (key) {
            var cacheValues = this.cacheValues;
            var data = cacheValues[key];
            if (data && this._check(key, data)) {
                return cacheValues[key].t;
            }
            return;
        };
        /**
         * 获取某个键值的最后修改时间。
         *
         * @param {string} key 键名称。
         * @returns {number | undefined} 如果未找到键或已过期，返回 `undefined`，否则返回一个以毫秒时间戳，表示键值最后修改时间。
         * @example
         * const myCache = new Cache();
         *
         * // 假如 Date.now() = 1673330000000
         * myCache.set('myKey', 'foo');
         * myCache.getLastModified('myKey'); // 1673330000000
         *
         * // 5000ms later
         * myCache.set('myKey', 'bar');
         * myCache.getLastModified('myKey'); // 1673330005000
         */
        Cache.prototype.getLastModified = function (key) {
            var cacheValues = this.cacheValues;
            var data = cacheValues[key];
            if (data && this._check(key, data)) {
                return cacheValues[key].n;
            }
            return;
        };
        /**
         * 启动定时校验过期数据。
         *
         * 注意，如果没有设置 `checkperiod` 将不会触发定时器。
         *
         * @example
         * // 设置 checkperiod 之后自动生效
         * const myCache = new Cache({
         *   checkperiod: 10 * 60 * 1000 // 10分钟检查一次数据是否过期
         * });
         *
         * // 停止定时校验过期数据
         * myCache.stopCheckperiod();
         *
         * // 启动定时校验过期数据
         * myCache.startCheckperiod();
         */
        Cache.prototype.startCheckperiod = function () {
            var _this = this;
            // 触发全部缓存数据是否过期校验
            this.keys();
            if (this.options.checkperiod > 0) {
                clearTimeout(this._checkTimeout);
                this._checkTimeout = setTimeout(function () {
                    _this.startCheckperiod();
                }, this.options.checkperiod);
            }
        };
        /**
         * 停止定时校验过期数据。
         *
         * @example
         * // 设置 checkperiod 之后自动生效
         * const myCache = new Cache({
         *   checkperiod: 10 * 60 * 1000 // 10分钟检查一次数据是否过期
         * });
         *
         * // 停止定时校验过期数据
         * myCache.stopCheckperiod();
         */
        Cache.prototype.stopCheckperiod = function () {
            clearTimeout(this._checkTimeout);
        };
        return Cache;
    }(EmitterPro));

    var AsyncMemo = (function () {
        function AsyncMemo(options) {
            this.promiseCache = {};
            this.cache = new Cache(uniqueId('uh_async_memo'), options);
        }
        AsyncMemo.prototype.run = function (asyncFn, key, options) {
            var _this = this;
            if (!key || !isString(key)) {
                return asyncFn();
            }
            var opts = __assign({ persisted: true }, options);
            if (opts.persisted) {
                var data = this.cache.get(key);
                if (data) {
                    return Promise.resolve(data);
                }
            }
            if (!this.promiseCache[key]) {
                this.promiseCache[key] = asyncFn()
                    .then(function (res) {
                    delete _this.promiseCache[key];
                    _this.cache.set(key, res, opts.ttl);
                    return res;
                })
                    .catch(function (err) {
                    delete _this.promiseCache[key];
                    return Promise.reject(err);
                });
            }
            return this.promiseCache[key];
        };
        return AsyncMemo;
    }());

    exports.AsyncMemo = AsyncMemo;
    exports.VERSION = VERSION;
    exports.ajax = ajax;
    exports.bytesToSize = bytesToSize;
    exports.calculateCursorPosition = calculateCursorPosition;
    exports.checkFileType = checkFileType;
    exports.checkResult = checkResult;
    exports.compressImage = compressImage;
    exports.dataURLToBlob = dataURLToBlob;
    exports.divide = divide;
    exports.download = download;
    exports.fileReader = fileReader;
    exports.filterTree = filterTree;
    exports.findTreeNode = findTreeNode;
    exports.findTreeNodes = findTreeNodes;
    exports.findTreeSelect = findTreeSelect;
    exports.formatBankCard = formatBankCard;
    exports.formatMobile = formatMobile;
    exports.formatMoney = formatMoney;
    exports.gcd = gcd;
    exports.getExtname = getExtname;
    exports.getFileBlob = getFileBlob;
    exports.getFileType = getFileType;
    exports.getImageInfo = getImageInfo;
    exports.getMimeType = getMimeType;
    exports.injectStyle = injectStyle;
    exports.isBankCard = isBankCard;
    exports.isBusinessLicense = isBusinessLicense;
    exports.isChinese = isChinese;
    exports.isEmail = isEmail;
    exports.isHMCard = isHMCard;
    exports.isIPv4 = isIPv4;
    exports.isIPv6 = isIPv6;
    exports.isIdCard = isIdCard;
    exports.isMobile = isMobile;
    exports.isPassport = isPassport;
    exports.isPassword = isPassword;
    exports.isPostcode = isPostcode;
    exports.isQQ = isQQ;
    exports.isSocialCreditCode = isSocialCreditCode;
    exports.isSwiftCode = isSwiftCode;
    exports.isTWCard = isTWCard;
    exports.isTelephone = isTelephone;
    exports.isUrl = isUrl;
    exports.isValidNumber = isValidNumber;
    exports.isVehicle = isVehicle;
    exports.isWX = isWX;
    exports.lcm = lcm;
    exports.listToTree = listToTree;
    exports.loadImage = loadImage;
    exports.loadImageWithBlob = loadImageWithBlob;
    exports.loadScript = loadScript;
    exports.minus = minus;
    exports.numberToChinese = numberToChinese;
    exports.padZero = padZero;
    exports.parseIdCard = parseIdCard;
    exports.plus = plus;
    exports.randomString = randomString$1;
    exports.replaceChar = replaceChar;
    exports.round = _round;
    exports.safeDate = safeDate;
    exports.setDataURLPrefix = setDataURLPrefix;
    exports.setDisableWarning = setDisableWarning;
    exports.strlen = strlen;
    exports.times = times;
    exports.transformFieldNames = transformFieldNames;
    exports.transformObjectValue = transformObjectValue;
    exports.treeToList = treeToList;
    exports.validatePassword = validatePassword;

}));
//# sourceMappingURL=util-helpers.js.map
