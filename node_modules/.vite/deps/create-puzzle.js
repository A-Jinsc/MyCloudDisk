import {
  AsyncMemo,
  loadImageWithBlob
} from "./chunk-XKEAOX2N.js";
import {
  isObject,
  randomInt,
  uniqueId
} from "./chunk-BNL6YVI4.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/create-puzzle/dist/createPuzzle.esm.js
var mathPI = Math.PI;
var Point;
(function(Point2) {
  Point2[Point2["None"] = 0] = "None";
  Point2[Point2["Outer"] = 1] = "Outer";
  Point2[Point2["Inner"] = 2] = "Inner";
})(Point || (Point = {}));
var pointArray = [Point.None, Point.Outer, Point.Inner];
function pick(arr) {
  var len = arr.length;
  var randomIndex = randomInt(0, len - 1);
  return arr[randomIndex];
}
function getRandomPoints(pointNum) {
  var points = {
    top: pick(pointArray),
    right: pick(pointArray),
    bottom: pick(pointArray),
    left: pick(pointArray)
  };
  var pointsKeys = Object.keys(points);
  var verticalDirs = ["top", "bottom"];
  var horizontalDirs = ["left", "right"];
  if (points.top === Point.Outer && points.bottom === Point.Outer) {
    points[pick(verticalDirs)] = Point.Inner;
  } else if (points.top !== Point.Outer && points.bottom !== Point.Outer) {
    points[pick(verticalDirs)] = Point.Outer;
  }
  if (points.left === Point.Outer && points.right === Point.Outer) {
    points[pick(horizontalDirs)] = Point.Inner;
  } else if (points.left !== Point.Outer && points.right !== Point.Outer) {
    points[pick(horizontalDirs)] = Point.Outer;
  }
  if (pointNum) {
    var inners_1 = [];
    var nones_1 = [];
    pointsKeys.forEach(function(item) {
      if (points[item] === Point.Inner) {
        inners_1.push(item);
      } else if (points[item] === Point.None) {
        nones_1.push(item);
      }
    });
    if (pointNum === 2) {
      inners_1.forEach(function(item) {
        return points[item] = Point.None;
      });
    } else if (pointNum === 3) {
      if (inners_1.length === 0) {
        points[pick(nones_1)] = Point.Inner;
      } else if (inners_1.length === 2) {
        points[pick(inners_1)] = Point.None;
      }
    } else if (pointNum == 4) {
      nones_1.forEach(function(item) {
        return points[item] = Point.Inner;
      });
    }
  }
  return points;
}
function drawPuzzle(ctx, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.x, x = _a === void 0 ? 0 : _a, _b = options.y, y = _b === void 0 ? 0 : _b, _c = options.w, w = _c === void 0 ? 60 : _c, _d = options.h, h = _d === void 0 ? 60 : _d, _e = options.needClosePath, needClosePath = _e === void 0 ? true : _e;
  var points = options.points, _f = options.margin, margin = _f === void 0 ? 0 : _f;
  margin = margin <= 0 ? 0 : margin;
  if (typeof points === "number" || !points) {
    points = getRandomPoints(points);
  }
  var r = (Math.min(w, h) - margin * 2) * 0.15;
  var l = Math.hypot(r, r);
  var l1_2 = l / 2;
  var c2r = r + l1_2;
  var rect = {
    x: x + margin,
    y: y + margin,
    w: w - c2r - margin * 2,
    h: h - c2r - margin * 2
  };
  var w1_2 = rect.w / 2;
  var h1_2 = rect.h / 2;
  if (points.left === Point.Outer) {
    rect.x += c2r;
  }
  if (points.top === Point.Outer) {
    rect.y += c2r;
  }
  ctx.beginPath();
  ctx.lineWidth = 2;
  ctx.moveTo(rect.x, rect.y);
  if (points.top !== Point.None) {
    ctx.lineTo(rect.x + w1_2 - l1_2, rect.y);
    if (points.top === Point.Inner) {
      ctx.arc(rect.x + w1_2, rect.y + l1_2, r, 1.25 * mathPI, 1.75 * mathPI, true);
    } else {
      ctx.arc(rect.x + w1_2, rect.y - l1_2, r, 0.75 * mathPI, 0.25 * mathPI);
    }
  }
  ctx.lineTo(rect.x + rect.w, rect.y);
  if (points.right !== Point.None) {
    ctx.lineTo(rect.x + rect.w, rect.y + h1_2 - l1_2);
    if (points.right === Point.Inner) {
      ctx.arc(rect.x + rect.w - l1_2, rect.y + h1_2, r, 1.75 * mathPI, 0.25 * mathPI, true);
    } else {
      ctx.arc(rect.x + rect.w + l1_2, rect.y + h1_2, r, 1.25 * mathPI, 0.75 * mathPI);
    }
  }
  ctx.lineTo(rect.x + rect.w, rect.y + rect.h);
  if (points.bottom !== Point.None) {
    ctx.lineTo(rect.x + w1_2 + l1_2, rect.y + rect.h);
    if (points.bottom === Point.Inner) {
      ctx.arc(rect.x + w1_2, rect.y + rect.h - l1_2, r, 0.25 * mathPI, 0.75 * mathPI, true);
    } else {
      ctx.arc(rect.x + w1_2, rect.y + rect.h + l1_2, r, 1.75 * mathPI, 1.25 * mathPI);
    }
  }
  ctx.lineTo(rect.x, rect.y + rect.h);
  if (points.left !== Point.None) {
    ctx.lineTo(rect.x, rect.y + h1_2 + l1_2);
    if (points.left === Point.Inner) {
      ctx.arc(rect.x + l1_2, rect.y + h1_2, r, 0.75 * mathPI, 1.25 * mathPI, true);
    } else {
      ctx.arc(rect.x - l1_2, rect.y + h1_2, r, 0.25 * mathPI, 1.75 * mathPI);
    }
  }
  ctx.lineTo(rect.x, rect.y);
  ctx.stroke();
  needClosePath && ctx.closePath();
}
function canvasToImage(canvas, formatBlob, type, quality) {
  return new Promise(function(resolve) {
    if (formatBlob) {
      canvas.toBlob(function(blob) {
        if (blob) {
          resolve(URL.createObjectURL(blob));
        } else {
          resolve(canvas.toDataURL(type, quality));
        }
      }, type, quality);
    } else {
      resolve(canvas.toDataURL(type, quality));
    }
  });
}
var asyncMemo = new AsyncMemo({ max: 5, maxStrategy: "replaced" });
asyncMemo.cache.on("del", function(k, v) {
  try {
    if (v.image.src) {
      URL.revokeObjectURL(v.image.src);
    }
  } catch (err) {
  }
});
function clearCache(key) {
  if (key) {
    asyncMemo.cache.del(key);
  } else {
    asyncMemo.cache.clear();
  }
}
var wm = /* @__PURE__ */ new WeakMap();
var getCacheKey = function(obj) {
  if (!isObject(obj)) {
    return String(obj);
  }
  if (!wm.get(obj)) {
    wm.set(obj, uniqueId("cp"));
  }
  return wm.get(obj);
};
var MimeType = {
  jpeg: "image/jpeg",
  png: "image/png"
};
var previousBlobUrlCache = [];
function revokeBlobUrls(blobUrls) {
  blobUrls.forEach(function(item) {
    URL.revokeObjectURL(item);
  });
}
function createPuzzle(imgUrl, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.borderWidth, borderWidth = _a === void 0 ? 2 : _a, _b = options.borderColor, borderColor = _b === void 0 ? "rgba(255,255,255,0.7)" : _b, _c = options.fillColor, fillColor = _c === void 0 ? "rgba(255,255,255,0.7)" : _c, outPoints = options.points, _d = options.width, width = _d === void 0 ? 60 : _d, _e = options.height, height = _e === void 0 ? 60 : _e, outX = options.x, outY = options.y, _f = options.margin, margin = _f === void 0 ? 2 : _f, _g = options.equalHeight, equalHeight = _g === void 0 ? true : _g, imageWidth = options.imageWidth, imageHeight = options.imageHeight, outBgWidth = options.bgWidth, outBgHeight = options.bgHeight, _h = options.bgOffset, outBgOffset = _h === void 0 ? [0, 0] : _h, _j = options.bgImageType, bgImageType = _j === void 0 ? MimeType.jpeg : _j, _k = options.quality, quality = _k === void 0 ? 0.8 : _k, _l = options.format, format = _l === void 0 ? "dataURL" : _l, _m = options.cacheImage, cacheImage = _m === void 0 ? true : _m, _o = options.autoRevokePreviousBlobUrl, autoRevokePreviousBlobUrl = _o === void 0 ? true : _o, ajaxOptions = options.ajaxOptions;
  return new Promise(function(resolve, reject) {
    var bgCanvas = document.createElement("canvas");
    var puzzleCanvas = document.createElement("canvas");
    var bgCtx = bgCanvas.getContext("2d");
    var puzzleCtx = puzzleCanvas.getContext("2d");
    var cacheKey = cacheImage ? getCacheKey(imgUrl) : void 0;
    asyncMemo.run(function() {
      return loadImageWithBlob(imgUrl, ajaxOptions);
    }, cacheKey).then(function(_a2) {
      var img = _a2.image;
      if (imageWidth) {
        img.width = imageWidth;
      }
      if (imageHeight) {
        img.height = imageHeight;
      }
      var bgWidth = typeof outBgWidth === "number" && outBgWidth > 0 ? outBgWidth > width ? outBgWidth : width : img.width;
      var bgHeight = typeof outBgHeight === "number" && outBgHeight > 0 ? outBgHeight > height ? outBgHeight : height : img.height;
      bgCanvas.width = bgWidth;
      bgCanvas.height = bgHeight;
      var maxOffsetX = bgWidth - width;
      var maxOffsetY = bgHeight - height;
      var x = typeof outX === "undefined" ? randomInt(width, maxOffsetX) : outX || 0;
      var y = typeof outY === "undefined" ? randomInt(0, maxOffsetY) : outY || 0;
      if (x < 0) {
        x = 0;
      } else if (x > maxOffsetX) {
        x = maxOffsetX;
      }
      if (y < 0) {
        y = 0;
      } else if (y > maxOffsetY) {
        y = maxOffsetY;
      }
      var points = typeof outPoints === "number" || !outPoints ? getRandomPoints(outPoints) : outPoints;
      var bgOffset = typeof outBgOffset === "function" ? outBgOffset(img.width, img.height) : outBgOffset;
      bgCtx.strokeStyle = borderColor;
      bgCtx.lineWidth = borderWidth;
      bgCtx.fillStyle = fillColor;
      drawPuzzle(bgCtx, { x, y, w: width, h: height, points, margin });
      bgCtx.fillStyle = fillColor;
      bgCtx.fill();
      bgCtx.globalCompositeOperation = "destination-over";
      bgCtx.drawImage(img, bgOffset[0], bgOffset[1], img.width, img.height);
      puzzleCanvas.width = bgWidth;
      puzzleCanvas.height = bgHeight;
      puzzleCtx.strokeStyle = borderColor;
      puzzleCtx.lineWidth = borderWidth;
      drawPuzzle(puzzleCtx, { x, y, w: width, h: height, points, margin });
      puzzleCtx.globalCompositeOperation = "destination-over";
      puzzleCtx.clip();
      puzzleCtx.drawImage(img, bgOffset[0], bgOffset[1], img.width, img.height);
      var imgData = puzzleCtx.getImageData(x, y, width, height);
      puzzleCtx.clearRect(0, 0, bgWidth, bgHeight);
      puzzleCanvas.width = width;
      puzzleCanvas.height = equalHeight ? bgHeight : height;
      puzzleCtx.putImageData(imgData, 0, equalHeight ? y : 0);
      var formatBlob = format === "blob";
      var puzzlePromise = canvasToImage(puzzleCanvas, formatBlob, MimeType.png, quality);
      var bgPromise = canvasToImage(bgCanvas, formatBlob, bgImageType, quality);
      Promise.all([puzzlePromise, bgPromise]).then(function(_a3) {
        var puzzleUrl = _a3[0], bgUrl = _a3[1];
        if (autoRevokePreviousBlobUrl) {
          if (previousBlobUrlCache.length) {
            revokeBlobUrls(previousBlobUrlCache);
            previousBlobUrlCache.length = 0;
          }
          if (formatBlob) {
            previousBlobUrlCache.push(bgUrl, puzzleUrl);
          }
        }
        resolve({
          puzzleUrl,
          bgUrl,
          x,
          y: equalHeight ? 0 : y
        });
      }).catch(reject);
    }).catch(reject);
  });
}
export {
  Point,
  clearCache,
  createPuzzle,
  createPuzzle as default,
  drawPuzzle,
  getRandomPoints
};
//# sourceMappingURL=create-puzzle.js.map
