{"version":3,"file":"emitter-pro.js","sources":["../src/index.ts"],"sourcesContent":["type Listener = (...args: any[]) => any;\n\ntype EventName = string | symbol;\ntype EventListener<F extends Listener = Listener> = { raw: F; wrap: F; context: object | null };\ntype Handler<F extends Listener = Listener> = Record<EventName, EventListener<F>[]>;\n\n/**\n * 事件触发器，支持浏览器端和 node 端。\n *\n * @class\n * @example\n *\n * const emitter = new Emitter();\n *\n * // 注册监听方法\n * emitter.on('foo', () => console.log('foo 1'));\n * emitter.on('foo', () => console.log('foo 2'));\n *\n * // 触发方法\n * emitter.emit('foo');\n * // foo 1\n * // foo 2\n *\n * // 取消监听方法\n * emitter.off('foo');\n *\n * // 支持链式调用\n * emitter.on('foo', () => {})\n *  .on('foo', () => {})\n *  .off('foo');\n */\nclass EmitterPro<F extends Listener = Listener> {\n  private handlers: Handler<F>;\n  constructor() {\n    this.handlers = {};\n  }\n\n  /**\n   * 获取全部事件名称。\n   *\n   * @returns 事件名称数组。\n   * @example\n   * emitter.on('foo', () => {});\n   * emitter.on('bar', () => {});\n   *\n   * emitter.eventNames(); // ['foo', 'bar']\n   */\n  eventNames() {\n    const symbols = Object.getOwnPropertySymbols?.(this.handlers) || [];\n    const keys = Object.keys(this.handlers) as (string | symbol)[];\n    return keys.concat(symbols);\n  }\n\n  /**\n   * 获取事件名称的全部监听方法（原始方法，未经过包装处理）。\n   *\n   * @param eventName 事件名称\n   * @returns 对应事件名称的监听方法数组\n   * @example\n   * const fn1 = () => console.log('bar');\n   * const fn2 = () => console.log('baz');\n   *\n   * emitter.on('test', fn1);\n   * emitter.once('test', fn2);\n   *\n   * emitter.rawListeners('test'); // [fn1, fn2]\n   */\n  rawListeners(eventName: EventName) {\n    const handler = this.handlers[eventName];\n    return handler ? handler.map((item) => item.raw) : [];\n  }\n\n  /**\n   * 获取事件名称的全部监听方法（如通过 `once` 方法注册，返回的是包装方法）。\n   *\n   * @param eventName 事件名称\n   * @returns 对应事件名称的监听方法数组\n   * @example\n   * const fn1 = () => console.log('bar');\n   * const fn2 = () => console.log('baz');\n   *\n   * emitter.on('test', fn1);\n   * emitter.once('test', fn2);\n   *\n   * emitter.rawListeners('test'); // [fn1, wrapFn2]\n   */\n  listeners(eventName: EventName) {\n    const handler = this.handlers[eventName];\n    return handler ? handler.map((item) => item.wrap) : [];\n  }\n\n  /**\n   * 判断事件名称对应的监听方法是否存在。\n   *\n   * @param eventName 事件名称\n   * @param listener 监听方法\n   * @returns 如果事件名称存在该事件方法返回 `true`，否则返回 `false`。\n   * @example\n   * const fn1 = () => console.log('bar');\n   * const fn2 = () => console.log('baz');\n   *\n   * emitter.on('test', fn1);\n   * emitter.once('test', fn2);\n   *\n   * emitter.hasListener('test', fn1); // true\n   * emitter.hasListener('test', fn2); // true\n   *\n   * // fn2 是通过 once 方法注册，执行一次后自动解绑\n   * emitter.emit('test');\n   *\n   * emitter.hasListener('test', fn1); // true\n   * emitter.hasListener('test', fn2); // false\n   */\n  hasListener(eventName: EventName, listener: F) {\n    return this.rawListeners(eventName).some((item) => item === listener);\n  }\n\n  private _on(\n    eventName: EventName,\n    raw: F,\n    wrap: F,\n    context: EventListener['context'] = null,\n    dir = 1\n  ) {\n    const currentListener = { raw, wrap, context };\n\n    if (!this.handlers[eventName]) {\n      this.handlers[eventName] = [currentListener];\n    } else {\n      const appendMethod = dir === 1 ? 'push' : 'unshift';\n      this.handlers[eventName][appendMethod](currentListener);\n    }\n\n    return this;\n  }\n\n  /**\n   * 注册监听方法。同 `on` 方法，只是将监听方法添加到最前面（事件触发是按顺序执行）。\n   *\n   * @param eventName 事件名称\n   * @param listener 监听方法\n   * @param context 执行上下文\n   * @returns 事件触发器实例。\n   * @example\n   * emitter.on('foo', () => console.log('bar'));\n   * emitter.prependListener('foo', () => console.log(42));\n   *\n   * emitter.emit('foo');\n   * // 42\n   * // bar\n   */\n  prependListener(eventName: EventName, listener: F, context?: EventListener['context']) {\n    return this._on(eventName, listener, listener, context, 0);\n  }\n\n  /**\n   * 注册监听方法。允许多次添加同一引用的函数。\n   *\n   * @param eventName 事件名称\n   * @param listener 监听方法\n   * @param context 执行上下文\n   * @returns 事件触发器实例。\n   * @example\n   * emitter.on('foo', () => console.log('bar'));\n   * emitter.on('foo', () => console.log(42));\n   *\n   * emitter.emit('foo');\n   * // bar\n   * // 42\n   */\n  on(eventName: EventName, listener: F, context?: EventListener['context']) {\n    return this._on(eventName, listener, listener, context);\n  }\n\n  private _wrapOnce(eventName: EventName, listener: F, context: EventListener['context'] = null) {\n    const wrap = ((...args: Parameters<F>) => {\n      listener.apply(context, args);\n      this.off(eventName, wrap);\n    }) as F;\n    return wrap;\n  }\n\n  /**\n   * 仅触发一次的监听方法。使用方法同 `on` 。\n   *\n   * @param eventName 事件名称\n   * @param listener 监听方法\n   * @param context 执行上下文\n   * @returns 事件触发器实例。\n   * @example\n   * emitter.on('foo', () => console.log('bar'));\n   * emitter.once('foo', () => console.log(42));\n   *\n   * emitter.emit('foo');\n   * // bar\n   * // 42\n   *\n   * emitter.emit('foo');\n   * // bar\n   */\n  once(eventName: EventName, listener: F, context?: EventListener['context']) {\n    const wrap = this._wrapOnce(eventName, listener, context);\n    return this._on(eventName, listener, wrap, context);\n  }\n\n  /**\n   * 仅触发一次的监听方法。同 `once` 方法，只是添加到最前面（事件触发是按顺序执行）。\n   *\n   * @param eventName 事件名称\n   * @param listener 监听方法\n   * @param context 执行上下文\n   * @returns 事件触发器实例。\n   * @example\n   * emitter.on('foo', () => console.log('bar'));\n   * emitter.prependOnceListener('foo', () => console.log(42));\n   *\n   * emitter.emit('foo');\n   * // 42\n   * // bar\n   *\n   * emitter.emit('foo');\n   * // bar\n   */\n  prependOnceListener(eventName: EventName, listener: F, context?: EventListener['context']) {\n    const wrap = this._wrapOnce(eventName, listener, context);\n    return this._on(eventName, listener, wrap, context, 0);\n  }\n\n  /**\n   * 取消监听方法。如果不传第二个参数，将取消该事件名称的全部监听方法。如果多次添加同一引用的函数，需要多次删除。\n   *\n   * @param eventName 事件名称\n   * @param listener 监听方法\n   * @returns 事件触发器实例。\n   * @example\n   * const fn = () => console.log('bar');\n   * emitter.on('foo', fn);\n   * emitter.on('foo', () => console.log('baz'));\n   * emitter.on('foo', () => console.log(42));\n   *\n   * emitter.emit('foo');\n   * // bar\n   * // baz\n   * // 42\n   *\n   * emitter.off('foo', fn); // 取消 foo 的监听方法 fn\n   *\n   * emitter.emit('foo');\n   * // bar\n   * // 42\n   *\n   * emitter.off('foo'); // 取消 foo 的全部监听方法\n   * emitter.emit('foo'); // 什么都没发生\n   */\n  off(eventName: EventName, listener?: F) {\n    const handler = this.handlers[eventName];\n\n    if (handler) {\n      if (listener) {\n        const index = handler.findIndex((item) => item.wrap === listener || item.raw === listener);\n        if (index !== -1) {\n          handler.splice(index, 1);\n        }\n      } else {\n        delete this.handlers[eventName];\n      }\n    }\n    return this;\n  }\n\n  /**\n   * 取消全部事件名称的监听方法。\n   *\n   * @returns 事件触发器实例。\n   * @example\n   * const fn = () => console.log('bar');\n   * emitter.on('test', fn);\n   * emitter.on('test', () => console.log('baz'));\n   * emitter.on('test', () => console.log(42));\n   *\n   * emitter.on('other', fn);\n   * emitter.on('other', () => console.log('baz'));\n   *\n   * emitter.emit('test');\n   * // bar\n   * // baz\n   * // 42\n   *\n   * emitter.emit('other');\n   * // bar\n   * // baz\n   *\n   * emitter.offAll(); // 取消全部监听方法\n   *\n   * emitter.emit('test'); // 什么都没发生\n   * emitter.emit('other'); // 什么都没发生\n   */\n  offAll() {\n    this.handlers = {};\n    return this;\n  }\n\n  /**\n   * 触发监听方法。\n   *\n   * @param eventName 事件名称\n   * @param args 触发监听方法的参数（从第二个参数开始都将传给监听方法）\n   * @returns 如果触发成功返回 `true`，否则返回 `false`。\n   * @example\n   * emitter.on('foo', () => console.log('bar'));\n   * emitter.on('foo', () => console.log(42));\n   *\n   * emitter.emit('foo');\n   * // bar\n   * // 42\n   *\n   * // 支持传入参数\n   * emitter.on('test' (a, b) => console.log(a + b));\n   * emitter.on('test' (a, b) => console.log(a * b));\n   *\n   * emitter.emit('other', 2, 5);\n   * // 7\n   * // 10\n   *\n   * emitter.emit('other', 5, 5);\n   * // 10\n   * // 25\n   */\n  emit(eventName: EventName, ...args: Parameters<F>) {\n    const handler = this.handlers[eventName];\n    if (handler && handler.length > 0) {\n      handler.forEach((listener) => {\n        listener.wrap.apply(listener.context, args);\n      });\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default EmitterPro;\n"],"names":[],"mappings":"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"}