{"version":3,"file":"emitter-pro.min.js","sources":["../src/index.ts"],"sourcesContent":["type Listener = (...args: any[]) => any;\n\ntype EventName = string | symbol;\ntype EventListener<F extends Listener = Listener> = { raw: F; wrap: F; context: object | null };\ntype Handler<F extends Listener = Listener> = Record<EventName, EventListener<F>[]>;\n\n/**\n * 事件触发器，支持浏览器端和 node 端。\n *\n * @class\n * @example\n *\n * const emitter = new Emitter();\n *\n * // 注册监听方法\n * emitter.on('foo', () => console.log('foo 1'));\n * emitter.on('foo', () => console.log('foo 2'));\n *\n * // 触发方法\n * emitter.emit('foo');\n * // foo 1\n * // foo 2\n *\n * // 取消监听方法\n * emitter.off('foo');\n *\n * // 支持链式调用\n * emitter.on('foo', () => {})\n *  .on('foo', () => {})\n *  .off('foo');\n */\nclass EmitterPro<F extends Listener = Listener> {\n  private handlers: Handler<F>;\n  constructor() {\n    this.handlers = {};\n  }\n\n  /**\n   * 获取全部事件名称。\n   *\n   * @returns 事件名称数组。\n   * @example\n   * emitter.on('foo', () => {});\n   * emitter.on('bar', () => {});\n   *\n   * emitter.eventNames(); // ['foo', 'bar']\n   */\n  eventNames() {\n    const symbols = Object.getOwnPropertySymbols?.(this.handlers) || [];\n    const keys = Object.keys(this.handlers) as (string | symbol)[];\n    return keys.concat(symbols);\n  }\n\n  /**\n   * 获取事件名称的全部监听方法（原始方法，未经过包装处理）。\n   *\n   * @param eventName 事件名称\n   * @returns 对应事件名称的监听方法数组\n   * @example\n   * const fn1 = () => console.log('bar');\n   * const fn2 = () => console.log('baz');\n   *\n   * emitter.on('test', fn1);\n   * emitter.once('test', fn2);\n   *\n   * emitter.rawListeners('test'); // [fn1, fn2]\n   */\n  rawListeners(eventName: EventName) {\n    const handler = this.handlers[eventName];\n    return handler ? handler.map((item) => item.raw) : [];\n  }\n\n  /**\n   * 获取事件名称的全部监听方法（如通过 `once` 方法注册，返回的是包装方法）。\n   *\n   * @param eventName 事件名称\n   * @returns 对应事件名称的监听方法数组\n   * @example\n   * const fn1 = () => console.log('bar');\n   * const fn2 = () => console.log('baz');\n   *\n   * emitter.on('test', fn1);\n   * emitter.once('test', fn2);\n   *\n   * emitter.rawListeners('test'); // [fn1, wrapFn2]\n   */\n  listeners(eventName: EventName) {\n    const handler = this.handlers[eventName];\n    return handler ? handler.map((item) => item.wrap) : [];\n  }\n\n  /**\n   * 判断事件名称对应的监听方法是否存在。\n   *\n   * @param eventName 事件名称\n   * @param listener 监听方法\n   * @returns 如果事件名称存在该事件方法返回 `true`，否则返回 `false`。\n   * @example\n   * const fn1 = () => console.log('bar');\n   * const fn2 = () => console.log('baz');\n   *\n   * emitter.on('test', fn1);\n   * emitter.once('test', fn2);\n   *\n   * emitter.hasListener('test', fn1); // true\n   * emitter.hasListener('test', fn2); // true\n   *\n   * // fn2 是通过 once 方法注册，执行一次后自动解绑\n   * emitter.emit('test');\n   *\n   * emitter.hasListener('test', fn1); // true\n   * emitter.hasListener('test', fn2); // false\n   */\n  hasListener(eventName: EventName, listener: F) {\n    return this.rawListeners(eventName).some((item) => item === listener);\n  }\n\n  private _on(\n    eventName: EventName,\n    raw: F,\n    wrap: F,\n    context: EventListener['context'] = null,\n    dir = 1\n  ) {\n    const currentListener = { raw, wrap, context };\n\n    if (!this.handlers[eventName]) {\n      this.handlers[eventName] = [currentListener];\n    } else {\n      const appendMethod = dir === 1 ? 'push' : 'unshift';\n      this.handlers[eventName][appendMethod](currentListener);\n    }\n\n    return this;\n  }\n\n  /**\n   * 注册监听方法。同 `on` 方法，只是将监听方法添加到最前面（事件触发是按顺序执行）。\n   *\n   * @param eventName 事件名称\n   * @param listener 监听方法\n   * @param context 执行上下文\n   * @returns 事件触发器实例。\n   * @example\n   * emitter.on('foo', () => console.log('bar'));\n   * emitter.prependListener('foo', () => console.log(42));\n   *\n   * emitter.emit('foo');\n   * // 42\n   * // bar\n   */\n  prependListener(eventName: EventName, listener: F, context?: EventListener['context']) {\n    return this._on(eventName, listener, listener, context, 0);\n  }\n\n  /**\n   * 注册监听方法。允许多次添加同一引用的函数。\n   *\n   * @param eventName 事件名称\n   * @param listener 监听方法\n   * @param context 执行上下文\n   * @returns 事件触发器实例。\n   * @example\n   * emitter.on('foo', () => console.log('bar'));\n   * emitter.on('foo', () => console.log(42));\n   *\n   * emitter.emit('foo');\n   * // bar\n   * // 42\n   */\n  on(eventName: EventName, listener: F, context?: EventListener['context']) {\n    return this._on(eventName, listener, listener, context);\n  }\n\n  private _wrapOnce(eventName: EventName, listener: F, context: EventListener['context'] = null) {\n    const wrap = ((...args: Parameters<F>) => {\n      listener.apply(context, args);\n      this.off(eventName, wrap);\n    }) as F;\n    return wrap;\n  }\n\n  /**\n   * 仅触发一次的监听方法。使用方法同 `on` 。\n   *\n   * @param eventName 事件名称\n   * @param listener 监听方法\n   * @param context 执行上下文\n   * @returns 事件触发器实例。\n   * @example\n   * emitter.on('foo', () => console.log('bar'));\n   * emitter.once('foo', () => console.log(42));\n   *\n   * emitter.emit('foo');\n   * // bar\n   * // 42\n   *\n   * emitter.emit('foo');\n   * // bar\n   */\n  once(eventName: EventName, listener: F, context?: EventListener['context']) {\n    const wrap = this._wrapOnce(eventName, listener, context);\n    return this._on(eventName, listener, wrap, context);\n  }\n\n  /**\n   * 仅触发一次的监听方法。同 `once` 方法，只是添加到最前面（事件触发是按顺序执行）。\n   *\n   * @param eventName 事件名称\n   * @param listener 监听方法\n   * @param context 执行上下文\n   * @returns 事件触发器实例。\n   * @example\n   * emitter.on('foo', () => console.log('bar'));\n   * emitter.prependOnceListener('foo', () => console.log(42));\n   *\n   * emitter.emit('foo');\n   * // 42\n   * // bar\n   *\n   * emitter.emit('foo');\n   * // bar\n   */\n  prependOnceListener(eventName: EventName, listener: F, context?: EventListener['context']) {\n    const wrap = this._wrapOnce(eventName, listener, context);\n    return this._on(eventName, listener, wrap, context, 0);\n  }\n\n  /**\n   * 取消监听方法。如果不传第二个参数，将取消该事件名称的全部监听方法。如果多次添加同一引用的函数，需要多次删除。\n   *\n   * @param eventName 事件名称\n   * @param listener 监听方法\n   * @returns 事件触发器实例。\n   * @example\n   * const fn = () => console.log('bar');\n   * emitter.on('foo', fn);\n   * emitter.on('foo', () => console.log('baz'));\n   * emitter.on('foo', () => console.log(42));\n   *\n   * emitter.emit('foo');\n   * // bar\n   * // baz\n   * // 42\n   *\n   * emitter.off('foo', fn); // 取消 foo 的监听方法 fn\n   *\n   * emitter.emit('foo');\n   * // bar\n   * // 42\n   *\n   * emitter.off('foo'); // 取消 foo 的全部监听方法\n   * emitter.emit('foo'); // 什么都没发生\n   */\n  off(eventName: EventName, listener?: F) {\n    const handler = this.handlers[eventName];\n\n    if (handler) {\n      if (listener) {\n        const index = handler.findIndex((item) => item.wrap === listener || item.raw === listener);\n        if (index !== -1) {\n          handler.splice(index, 1);\n        }\n      } else {\n        delete this.handlers[eventName];\n      }\n    }\n    return this;\n  }\n\n  /**\n   * 取消全部事件名称的监听方法。\n   *\n   * @returns 事件触发器实例。\n   * @example\n   * const fn = () => console.log('bar');\n   * emitter.on('test', fn);\n   * emitter.on('test', () => console.log('baz'));\n   * emitter.on('test', () => console.log(42));\n   *\n   * emitter.on('other', fn);\n   * emitter.on('other', () => console.log('baz'));\n   *\n   * emitter.emit('test');\n   * // bar\n   * // baz\n   * // 42\n   *\n   * emitter.emit('other');\n   * // bar\n   * // baz\n   *\n   * emitter.offAll(); // 取消全部监听方法\n   *\n   * emitter.emit('test'); // 什么都没发生\n   * emitter.emit('other'); // 什么都没发生\n   */\n  offAll() {\n    this.handlers = {};\n    return this;\n  }\n\n  /**\n   * 触发监听方法。\n   *\n   * @param eventName 事件名称\n   * @param args 触发监听方法的参数（从第二个参数开始都将传给监听方法）\n   * @returns 如果触发成功返回 `true`，否则返回 `false`。\n   * @example\n   * emitter.on('foo', () => console.log('bar'));\n   * emitter.on('foo', () => console.log(42));\n   *\n   * emitter.emit('foo');\n   * // bar\n   * // 42\n   *\n   * // 支持传入参数\n   * emitter.on('test' (a, b) => console.log(a + b));\n   * emitter.on('test' (a, b) => console.log(a * b));\n   *\n   * emitter.emit('other', 2, 5);\n   * // 7\n   * // 10\n   *\n   * emitter.emit('other', 5, 5);\n   * // 10\n   * // 25\n   */\n  emit(eventName: EventName, ...args: Parameters<F>) {\n    const handler = this.handlers[eventName];\n    if (handler && handler.length > 0) {\n      handler.forEach((listener) => {\n        listener.wrap.apply(listener.context, args);\n      });\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default EmitterPro;\n"],"names":["EmitterPro","this","handlers","prototype","eventNames","symbols","_a","Object","getOwnPropertySymbols","call","keys","concat","rawListeners","eventName","handler","map","item","raw","listeners","wrap","hasListener","listener","some","_on","context","dir","currentListener","appendMethod","prependListener","on","_wrapOnce","_this","args","_i","arguments","length","apply","off","once","prependOnceListener","index","findIndex","splice","offAll","emit","forEach"],"mappings":"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"}