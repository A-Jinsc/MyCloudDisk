'use strict';

/**
 * 事件触发器，支持浏览器端和 node 端。
 *
 * @class
 * @example
 *
 * const emitter = new Emitter();
 *
 * // 注册监听方法
 * emitter.on('foo', () => console.log('foo 1'));
 * emitter.on('foo', () => console.log('foo 2'));
 *
 * // 触发方法
 * emitter.emit('foo');
 * // foo 1
 * // foo 2
 *
 * // 取消监听方法
 * emitter.off('foo');
 *
 * // 支持链式调用
 * emitter.on('foo', () => {})
 *  .on('foo', () => {})
 *  .off('foo');
 */
var EmitterPro = /** @class */ (function () {
    function EmitterPro() {
        this.handlers = {};
    }
    /**
     * 获取全部事件名称。
     *
     * @returns 事件名称数组。
     * @example
     * emitter.on('foo', () => {});
     * emitter.on('bar', () => {});
     *
     * emitter.eventNames(); // ['foo', 'bar']
     */
    EmitterPro.prototype.eventNames = function () {
        var _a;
        var symbols = ((_a = Object.getOwnPropertySymbols) === null || _a === void 0 ? void 0 : _a.call(Object, this.handlers)) || [];
        var keys = Object.keys(this.handlers);
        return keys.concat(symbols);
    };
    /**
     * 获取事件名称的全部监听方法（原始方法，未经过包装处理）。
     *
     * @param eventName 事件名称
     * @returns 对应事件名称的监听方法数组
     * @example
     * const fn1 = () => console.log('bar');
     * const fn2 = () => console.log('baz');
     *
     * emitter.on('test', fn1);
     * emitter.once('test', fn2);
     *
     * emitter.rawListeners('test'); // [fn1, fn2]
     */
    EmitterPro.prototype.rawListeners = function (eventName) {
        var handler = this.handlers[eventName];
        return handler ? handler.map(function (item) { return item.raw; }) : [];
    };
    /**
     * 获取事件名称的全部监听方法（如通过 `once` 方法注册，返回的是包装方法）。
     *
     * @param eventName 事件名称
     * @returns 对应事件名称的监听方法数组
     * @example
     * const fn1 = () => console.log('bar');
     * const fn2 = () => console.log('baz');
     *
     * emitter.on('test', fn1);
     * emitter.once('test', fn2);
     *
     * emitter.rawListeners('test'); // [fn1, wrapFn2]
     */
    EmitterPro.prototype.listeners = function (eventName) {
        var handler = this.handlers[eventName];
        return handler ? handler.map(function (item) { return item.wrap; }) : [];
    };
    /**
     * 判断事件名称对应的监听方法是否存在。
     *
     * @param eventName 事件名称
     * @param listener 监听方法
     * @returns 如果事件名称存在该事件方法返回 `true`，否则返回 `false`。
     * @example
     * const fn1 = () => console.log('bar');
     * const fn2 = () => console.log('baz');
     *
     * emitter.on('test', fn1);
     * emitter.once('test', fn2);
     *
     * emitter.hasListener('test', fn1); // true
     * emitter.hasListener('test', fn2); // true
     *
     * // fn2 是通过 once 方法注册，执行一次后自动解绑
     * emitter.emit('test');
     *
     * emitter.hasListener('test', fn1); // true
     * emitter.hasListener('test', fn2); // false
     */
    EmitterPro.prototype.hasListener = function (eventName, listener) {
        return this.rawListeners(eventName).some(function (item) { return item === listener; });
    };
    EmitterPro.prototype._on = function (eventName, raw, wrap, context, dir) {
        if (context === void 0) { context = null; }
        if (dir === void 0) { dir = 1; }
        var currentListener = { raw: raw, wrap: wrap, context: context };
        if (!this.handlers[eventName]) {
            this.handlers[eventName] = [currentListener];
        }
        else {
            var appendMethod = dir === 1 ? 'push' : 'unshift';
            this.handlers[eventName][appendMethod](currentListener);
        }
        return this;
    };
    /**
     * 注册监听方法。同 `on` 方法，只是将监听方法添加到最前面（事件触发是按顺序执行）。
     *
     * @param eventName 事件名称
     * @param listener 监听方法
     * @param context 执行上下文
     * @returns 事件触发器实例。
     * @example
     * emitter.on('foo', () => console.log('bar'));
     * emitter.prependListener('foo', () => console.log(42));
     *
     * emitter.emit('foo');
     * // 42
     * // bar
     */
    EmitterPro.prototype.prependListener = function (eventName, listener, context) {
        return this._on(eventName, listener, listener, context, 0);
    };
    /**
     * 注册监听方法。允许多次添加同一引用的函数。
     *
     * @param eventName 事件名称
     * @param listener 监听方法
     * @param context 执行上下文
     * @returns 事件触发器实例。
     * @example
     * emitter.on('foo', () => console.log('bar'));
     * emitter.on('foo', () => console.log(42));
     *
     * emitter.emit('foo');
     * // bar
     * // 42
     */
    EmitterPro.prototype.on = function (eventName, listener, context) {
        return this._on(eventName, listener, listener, context);
    };
    EmitterPro.prototype._wrapOnce = function (eventName, listener, context) {
        var _this = this;
        if (context === void 0) { context = null; }
        var wrap = (function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            listener.apply(context, args);
            _this.off(eventName, wrap);
        });
        return wrap;
    };
    /**
     * 仅触发一次的监听方法。使用方法同 `on` 。
     *
     * @param eventName 事件名称
     * @param listener 监听方法
     * @param context 执行上下文
     * @returns 事件触发器实例。
     * @example
     * emitter.on('foo', () => console.log('bar'));
     * emitter.once('foo', () => console.log(42));
     *
     * emitter.emit('foo');
     * // bar
     * // 42
     *
     * emitter.emit('foo');
     * // bar
     */
    EmitterPro.prototype.once = function (eventName, listener, context) {
        var wrap = this._wrapOnce(eventName, listener, context);
        return this._on(eventName, listener, wrap, context);
    };
    /**
     * 仅触发一次的监听方法。同 `once` 方法，只是添加到最前面（事件触发是按顺序执行）。
     *
     * @param eventName 事件名称
     * @param listener 监听方法
     * @param context 执行上下文
     * @returns 事件触发器实例。
     * @example
     * emitter.on('foo', () => console.log('bar'));
     * emitter.prependOnceListener('foo', () => console.log(42));
     *
     * emitter.emit('foo');
     * // 42
     * // bar
     *
     * emitter.emit('foo');
     * // bar
     */
    EmitterPro.prototype.prependOnceListener = function (eventName, listener, context) {
        var wrap = this._wrapOnce(eventName, listener, context);
        return this._on(eventName, listener, wrap, context, 0);
    };
    /**
     * 取消监听方法。如果不传第二个参数，将取消该事件名称的全部监听方法。如果多次添加同一引用的函数，需要多次删除。
     *
     * @param eventName 事件名称
     * @param listener 监听方法
     * @returns 事件触发器实例。
     * @example
     * const fn = () => console.log('bar');
     * emitter.on('foo', fn);
     * emitter.on('foo', () => console.log('baz'));
     * emitter.on('foo', () => console.log(42));
     *
     * emitter.emit('foo');
     * // bar
     * // baz
     * // 42
     *
     * emitter.off('foo', fn); // 取消 foo 的监听方法 fn
     *
     * emitter.emit('foo');
     * // bar
     * // 42
     *
     * emitter.off('foo'); // 取消 foo 的全部监听方法
     * emitter.emit('foo'); // 什么都没发生
     */
    EmitterPro.prototype.off = function (eventName, listener) {
        var handler = this.handlers[eventName];
        if (handler) {
            if (listener) {
                var index = handler.findIndex(function (item) { return item.wrap === listener || item.raw === listener; });
                if (index !== -1) {
                    handler.splice(index, 1);
                }
            }
            else {
                delete this.handlers[eventName];
            }
        }
        return this;
    };
    /**
     * 取消全部事件名称的监听方法。
     *
     * @returns 事件触发器实例。
     * @example
     * const fn = () => console.log('bar');
     * emitter.on('test', fn);
     * emitter.on('test', () => console.log('baz'));
     * emitter.on('test', () => console.log(42));
     *
     * emitter.on('other', fn);
     * emitter.on('other', () => console.log('baz'));
     *
     * emitter.emit('test');
     * // bar
     * // baz
     * // 42
     *
     * emitter.emit('other');
     * // bar
     * // baz
     *
     * emitter.offAll(); // 取消全部监听方法
     *
     * emitter.emit('test'); // 什么都没发生
     * emitter.emit('other'); // 什么都没发生
     */
    EmitterPro.prototype.offAll = function () {
        this.handlers = {};
        return this;
    };
    /**
     * 触发监听方法。
     *
     * @param eventName 事件名称
     * @param args 触发监听方法的参数（从第二个参数开始都将传给监听方法）
     * @returns 如果触发成功返回 `true`，否则返回 `false`。
     * @example
     * emitter.on('foo', () => console.log('bar'));
     * emitter.on('foo', () => console.log(42));
     *
     * emitter.emit('foo');
     * // bar
     * // 42
     *
     * // 支持传入参数
     * emitter.on('test' (a, b) => console.log(a + b));
     * emitter.on('test' (a, b) => console.log(a * b));
     *
     * emitter.emit('other', 2, 5);
     * // 7
     * // 10
     *
     * emitter.emit('other', 5, 5);
     * // 10
     * // 25
     */
    EmitterPro.prototype.emit = function (eventName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var handler = this.handlers[eventName];
        if (handler && handler.length > 0) {
            handler.forEach(function (listener) {
                listener.wrap.apply(listener.context, args);
            });
            return true;
        }
        return false;
    };
    return EmitterPro;
}());

module.exports = EmitterPro;
