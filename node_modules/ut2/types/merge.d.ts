type GetKeysMethod = <T extends object>(object: T) => (symbol | string)[];
type Customizer = (objValue: any, srcValue: any, key: string | symbol, object: any, source: any) => any;
/**
 * 递归合并 `source` 来源对象自身的可枚举属性（包含 `Symbol` 属性）到 `object` 目标对象。
 *
 * 如果目标值存在，被解析为 `undefined` 的 `source` 来源对象属性将被跳过。数组和普通对象会递归合并，其他对象和值会被直接分配覆盖。
 *
 * 如果不需要合并数组，第三个参数传入 `merge.NOT_MERGE_ARRAYS` 。
 *
 * 如果需要合并继承的属性，第四个参数传入 {@link https://caijf.github.io/ut2/module-Object.html#.allKeysIn allKeysIn} 方法， `merge(object, source, undefined, allKeysIn)`。
 *
 * @alias module:Object.merge
 * @since 1.0.0
 * @param {Object | Array} object 目标对象。
 * @param {Object | Array} source 来源对象。
 * @param {Function} [customizer] 自定义赋值函数，如果函数返回 `undefined` 将使用默认合并。
 * @param {Function} [getKeys=allKeys] 自定义获取对象键方法。默认 `allKeys`。
 * @returns {Object} 目标对象。
 * @example
 *
 * merge({c: 3}, {e: 5}); // { c: 3, e: 5 }
 * merge({ a: 1 }, { a: undefined, b: undefined }); // { a: 1, b: undefined }
 *
 * const object = {
 *   a: [{b: 2}, {d: 4}]
 * }
 * const other = {
 *   a: [{c: 3},{e: 5}]
 * }
 *
 * merge(object, other); // { a: [{b: 2, c: 3}, {d: 4, e: 5}] }
 *
 * // 数组不合并
 * merge(object, other, merge.NOT_MERGE_ARRAYS); // { a: [{c: 3},{e: 5}] }
 *
 * // 或自定义数组不合并方法
 * merge(object, other, (objValue, srcValue) => isArray(srcValue) ? srcValue : undefined); // { a: [{c: 3},{e: 5}] }
 *
 */
declare function merge<TObject, TSource>(object: TObject, source: TSource, customizer?: Customizer, getKeys?: GetKeysMethod): TObject & TSource;
declare namespace merge {
    var NOT_MERGE_ARRAYS: (objValue: any, srcValue: any) => any[] | undefined;
}
export default merge;
