(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ut2 = {}));
})(this, (function (exports) { 'use strict';

    var nativeUndefined = void 0;
    var stringUndefined = 'undefined';
    var stringObject = 'object';
    var objectProto = Object.prototype;
    var objectProtoToString = objectProto.toString;
    var objectProtoHasOwnProperty = objectProto.hasOwnProperty;
    var objectProtoPropertyIsEnumerable = objectProto.propertyIsEnumerable;
    var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
    var objectGetPrototypeOf = Object.getPrototypeOf;
    var objectKeys = Object.keys;
    var functionProto = Function.prototype;
    var functionProtoToString = functionProto.toString;
    var symbolExisted = typeof Symbol !== stringUndefined;
    var symbolProto = symbolExisted ? Symbol.prototype : nativeUndefined;
    var arrayProto = Array.prototype;
    var arrayProtoSlice = arrayProto.slice;
    var mathMin = Math.min;
    var mathMax = Math.max;
    var mathRandom = Math.random;
    var mathFloor = Math.floor;
    var mathCeil = Math.ceil;
    var mathAbs = Math.abs;
    var numberIsFinite = Number.isFinite;
    var numberIsInteger = Number.isInteger;
    var numberIsSafeInteger = Number.isSafeInteger;
    var globalThisExisted = typeof globalThis === stringObject && globalThis;
    var globalExisted = typeof global === stringObject && global;
    var selfExisted = typeof self === stringObject && self;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var MAX_ARRAY_LENGTH = 4294967295;
    var bigIntTag = '[object BigInt]';
    var numberTag = '[object Number]';
    var booleanTag = '[object Boolean]';
    var stringTag = '[object String]';
    var dateTag = '[object Date]';
    var regExpTag = '[object RegExp]';
    var symbolTag = '[object Symbol]';
    var errorTag = '[object Error]';
    var arrayBufferTag = '[object ArrayBuffer]';
    var argumentsTag = '[object Arguments]';
    var arrayTag = '[object Array]';
    var functionTags = ['Function', 'AsyncFunction', 'GeneratorFunction', 'Proxy'].map(function (item) { return '[object ' + item + ']'; });
    var weakSetTag = '[object WeakSet]';
    var blobTag = '[object Blob]';
    var fileTag = '[object File]';
    var domExceptionTag = '[object DOMException]';
    var objectTag = '[object Object]';
    var dataViewTag = '[object DataView]';
    var mapTag = '[object Map]';
    var promiseTag = '[object Promise]';
    var setTag = '[object Set]';
    var weakMapTag = '[object WeakMap]';
    var windowTag = '[object Window]';

    function isArray(value) {
        return Array.isArray(value);
    }

    function isObjectLike(value) {
        return value !== null && typeof value === 'object';
    }

    function isObject(value) {
        return typeof value === 'function' || isObjectLike(value);
    }

    function getTag(value) {
        return objectProtoToString.call(value);
    }

    function isSymbol(value) {
        return typeof value === 'symbol' || getTag(value) === symbolTag;
    }

    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    function toNumber(value) {
        if (typeof value === 'number') {
            return value;
        }
        if (isSymbol(value)) {
            return NaN;
        }
        if (isObject(value)) {
            value = Number(value);
        }
        if (typeof value !== 'string') {
            return value === 0 ? value : +value;
        }
        value = value.trim();
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? parseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NaN : +value;
    }

    function toInteger(value) {
        var result = toNumber(value);
        if (!result || result === Infinity || result === -Infinity) {
            return result === result ? result : 0;
        }
        var remainder = result % 1;
        return remainder ? result - remainder : result;
    }

    function toLength(value) {
        value = toInteger(value);
        if (!value) {
            return 0;
        }
        if (value < 0) {
            return 0;
        }
        if (value > MAX_ARRAY_LENGTH) {
            return MAX_ARRAY_LENGTH;
        }
        return value;
    }

    function chunk(array, size) {
        if (size === void 0) { size = 1; }
        size = toLength(size);
        if (!isArray(array) || size < 1) {
            return [];
        }
        var length = array.length;
        var result = Array(mathCeil(length / size));
        var resIndex = 0, index = 0;
        while (index < length) {
            result[resIndex++] = array.slice(index, (index += size));
        }
        return result;
    }

    function compact(array) {
        return isArray(array) ? array.filter(function (item) { return !!item; }) : [];
    }

    function eq(value, other, strictCheck) {
        if (strictCheck === void 0) { strictCheck = false; }
        if (value === other) {
            return strictCheck ? value !== 0 || 1 / value === 1 / other : true;
        }
        return value !== value && other !== other;
    }

    function identity(value) {
        return value;
    }

    function createIteratee(iteratee) {
        if (typeof iteratee === 'function') {
            return iteratee;
        }
        if (typeof iteratee === 'string' || typeof iteratee === 'number' || isSymbol(iteratee)) {
            return function (value) { return value[iteratee]; };
        }
        return identity;
    }

    function difference(array, values, iteratee, strictCheck) {
        if (iteratee === void 0) { iteratee = identity; }
        if (strictCheck === void 0) { strictCheck = false; }
        if (!isArray(array)) {
            return [];
        }
        if (!isArray(values)) {
            return array;
        }
        var internalIteratee = createIteratee(iteratee);
        return array.filter(function (item) {
            var current = internalIteratee(item);
            return values.findIndex(function (value) { return eq(internalIteratee(value), current, strictCheck); }) === -1;
        });
    }

    var fromPairs = function (array) {
        var result = {};
        if (!isArray(array)) {
            return result;
        }
        array.forEach(function (item) {
            result[item[0]] = item[1];
        });
        return result;
    };

    function intersection(array, other, iteratee, strictCheck) {
        if (iteratee === void 0) { iteratee = identity; }
        if (strictCheck === void 0) { strictCheck = false; }
        if (!isArray(array) || !isArray(other)) {
            return [];
        }
        var internalIteratee = createIteratee(iteratee);
        var caches = [];
        return array.filter(function (item) {
            var current = internalIteratee(item);
            if (other.findIndex(function (value) { return eq(internalIteratee(value), current, strictCheck); }) !== -1 && !caches.includes(current)) {
                caches.push(current);
                return true;
            }
            return false;
        });
    }

    function move(array, from, to) {
        array.splice(to, 0, array.splice(from, 1)[0]);
        return array;
    }

    function isFunction(value) {
        if (typeof value === 'function') {
            return true;
        }
        var tag = getTag(value);
        return functionTags.some(function (item) { return item === tag; });
    }

    function isLength(value) {
        return typeof value === 'number' && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER;
    }

    function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
    }

    var nth = function (array, n) {
        if (n === void 0) { n = 0; }
        if (!isArrayLike(array)) {
            return nativeUndefined;
        }
        n += n < 0 ? array.length : 0;
        return array[n];
    };

    var MAX_VALUE = 1.7976931348623157e308;
    function toFinite(value) {
        if (!value) {
            return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === Infinity || value === -Infinity) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_VALUE;
        }
        return value === value ? value : 0;
    }

    function randomInt(lower, upper) {
        if (lower === void 0) { lower = 0; }
        if (upper === void 0) { upper = 1; }
        lower = toFinite(lower);
        upper = toFinite(upper);
        var min = mathCeil(mathMin(lower, upper) || 0);
        var max = mathFloor(mathMax(lower, upper) || 0);
        if (min > max) {
            var temp = min;
            min = max;
            max = temp;
        }
        return mathFloor(min + mathRandom() * (max - min + 1));
    }

    function shuffle(array) {
        if (!isArray(array) || array.length < 1) {
            return [];
        }
        var result = array.slice();
        var length = result.length;
        var lastIndex = length - 1;
        var index = -1;
        while (++index < length) {
            var rand = randomInt(index, lastIndex);
            var value = result[rand];
            result[rand] = result[index];
            result[index] = value;
        }
        return result;
    }

    function uniq(array, iteratee, strickCheck) {
        if (strickCheck === void 0) { strickCheck = false; }
        if (!isArray(array)) {
            return [];
        }
        var internalIteratee = createIteratee(iteratee);
        return array.filter(function (value, index, arr) {
            var current = internalIteratee(value);
            return arr.findIndex(function (item) { return eq(internalIteratee(item), current, strickCheck); }) === index;
        });
    }

    function union(array, other, iteratee, strickCheck) {
        if (other === void 0) { other = []; }
        if (strickCheck === void 0) { strickCheck = false; }
        array = isArray(array) ? array : [];
        other = isArray(other) ? other : [];
        return uniq(array.concat(other), iteratee, strickCheck);
    }

    function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
    }

    function unzip(array) {
        if (!isArray(array) || array.length === 0) {
            return [];
        }
        var length = 0;
        array = array.filter(function (group) {
            if (isArrayLikeObject(group)) {
                length = mathMax(group.length, length);
                return true;
            }
            return false;
        });
        var result = Array(length);
        var index = -1;
        while (++index < length) {
            var item = array.map(function (group) { return group[index]; });
            result[index] = item;
        }
        return result;
    }

    function xor(array, other, iteratee, strickCheck) {
        if (other === void 0) { other = []; }
        if (iteratee === void 0) { iteratee = identity; }
        if (strickCheck === void 0) { strickCheck = false; }
        if (!isArray(array) && !isArray(other)) {
            return [];
        }
        var internalIteratee = createIteratee(iteratee);
        if (!isArray(other)) {
            return uniq(array, internalIteratee, strickCheck);
        }
        if (!isArray(array)) {
            return uniq(other, internalIteratee, strickCheck);
        }
        return difference(union(array, other, internalIteratee, strickCheck), intersection(array, other, internalIteratee, strickCheck), internalIteratee, strickCheck);
    }

    function zip() {
        var arrays = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arrays[_i] = arguments[_i];
        }
        return unzip(arrays);
    }

    function getSymbols(object) {
        if (!objectGetOwnPropertySymbols || object === null) {
            return [];
        }
        return objectGetOwnPropertySymbols(object).filter(function (item) { return objectProtoPropertyIsEnumerable.call(object, item); });
    }

    function allKeys(object) {
        if (!isObject(object)) {
            return [];
        }
        return objectKeys(object).concat(getSymbols(object));
    }

    function createForEach(dir) {
        var forEach = function (collection, iteratee) {
            if (iteratee === void 0) { iteratee = identity; }
            var _keys = !isArrayLike(collection) && allKeys(collection);
            var len = (_keys || collection).length;
            var i = dir > 0 ? 0 : len - 1;
            while (i >= 0 && i < len) {
                var currentKey = _keys ? _keys[i] : i;
                if (iteratee(collection[currentKey], currentKey, collection) === false) {
                    break;
                }
                i += dir;
            }
            return collection;
        };
        return forEach;
    }

    var forEach = createForEach(1);

    var countBy = function (collection, iteratee) {
        var result = {};
        var internalIteratee = createIteratee(iteratee);
        forEach(collection, function (item, index, arr) {
            var key = internalIteratee(item, index, arr);
            if (key in result) {
                ++result[key];
            }
            else {
                result[key] = 1;
            }
        });
        return result;
    };

    var every = function (collection, predicate) {
        if (predicate === void 0) { predicate = identity; }
        var result = true;
        forEach(collection, function (item, index, arr) {
            if (!predicate(item, index, arr)) {
                result = false;
                return false;
            }
        });
        return result;
    };

    var find = function (collection, predicate) {
        if (predicate === void 0) { predicate = identity; }
        var result;
        forEach(collection, function (item, index, arr) {
            if (predicate(item, index, arr)) {
                result = item;
                return false;
            }
        });
        return result;
    };

    var filter = function (array, predicate) {
        if (predicate === void 0) { predicate = identity; }
        var results = [];
        forEach(array, function (item, index) {
            if (predicate(item, index, array)) {
                results.push(item);
            }
        });
        return results;
    };

    var forEachRight = createForEach(-1);

    var groupBy = function (collection, iteratee) {
        if (iteratee === void 0) { iteratee = identity; }
        var result = {};
        var internalIteratee = createIteratee(iteratee);
        forEach(collection, function (item, index, arr) {
            var key = internalIteratee(item, index, arr);
            if (key in result) {
                result[key].push(item);
            }
            else {
                result[key] = [item];
            }
        });
        return result;
    };

    var keyBy = function (collection, iteratee) {
        if (iteratee === void 0) { iteratee = identity; }
        var result = {};
        var internalIteratee = createIteratee(iteratee);
        forEach(collection, function (item, index, arr) {
            var key = internalIteratee(item, index, arr);
            result[key] = item;
        });
        return result;
    };

    function isNumber(value) {
        return typeof value === 'number' || getTag(value) === numberTag;
    }

    function isNil(value) {
        return value == null;
    }

    var symbolToString = symbolProto ? symbolProto.toString : nativeUndefined;
    function baseToString(value) {
        if (typeof value === 'string') {
            return value;
        }
        if (isArray(value)) {
            return '' + value.map(baseToString);
        }
        if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : '';
        }
        var result = '' + value;
        return result === '0' && 1 / value === -Infinity ? '-0' : result;
    }
    function toString(value) {
        return isNil(value) ? '' : baseToString(value);
    }

    function createCompare(dir) {
        var asc = dir === 1;
        function wrapper(value, other) {
            var valueIsSymbol = isSymbol(value);
            var otherIsSymbol = isSymbol(other);
            var isNeedConvertString = !valueIsSymbol && !otherIsSymbol && !(isNumber(value) && isNumber(other));
            var _value = isNeedConvertString ? toString(value) : value;
            var _other = isNeedConvertString ? toString(other) : other;
            if (!otherIsSymbol && (valueIsSymbol || _value > _other)) {
                return asc ? 1 : -1;
            }
            if (!valueIsSymbol && (otherIsSymbol || _value < _other)) {
                return asc ? -1 : 1;
            }
            return 0;
        }
        return wrapper;
    }
    function compareMultiple(object, other, orders) {
        var objCriteria = object.criteria;
        var othCriteria = other.criteria;
        var length = objCriteria.length;
        var index = -1;
        while (++index < length) {
            var order = orders[index];
            var cmpFn = typeof order === 'function' ? order : order === 'desc' ? createCompare(0) : createCompare(1);
            var result = cmpFn(objCriteria[index], othCriteria[index]);
            if (result) {
                return result;
            }
        }
        return object.index - other.index;
    }

    var orderBy = function (collection, iteratees, orders) {
        var result = [];
        iteratees = (isArray(iteratees) ? iteratees : iteratees !== nativeUndefined ? [iteratees] : [identity]);
        orders = (isArray(orders) ? orders : orders !== nativeUndefined ? [orders] : []);
        var index = -1;
        forEach(collection, function (item, key, arr) {
            var criteria = iteratees.map(function (iteratee) { return createIteratee(iteratee)(item, key, arr); });
            result.push({
                criteria: criteria,
                index: ++index,
                value: item
            });
        });
        return result.sort(function (a, b) { return compareMultiple(a, b, orders); }).map(function (item) { return item.value; });
    };

    var map = function (collection, iteratee) {
        if (iteratee === void 0) { iteratee = identity; }
        var result = [];
        forEach(collection, function (item, index, arr) {
            result.push(iteratee(item, index, arr));
        });
        return result;
    };

    var partition = function (collection, predicate) {
        if (predicate === void 0) { predicate = identity; }
        var result = [[], []];
        var internalIteratee = createIteratee(predicate);
        forEach(collection, function (item, index, arr) {
            result[internalIteratee(item, index, arr) ? 0 : 1].push(item);
        });
        return result;
    };

    function createReduce(dir) {
        function reducer(collection, iteratee, memo, initial) {
            var _keys = !isArrayLike(collection) && allKeys(collection);
            var len = (_keys || collection).length;
            var i = dir > 0 ? 0 : len - 1;
            if (!initial && len > 0) {
                memo = collection[_keys ? _keys[i] : i];
                i += dir;
            }
            while (i >= 0 && i < len) {
                var currentKey = _keys ? _keys[i] : i;
                memo = iteratee(memo, collection[currentKey], currentKey, collection);
                i += dir;
            }
            return memo;
        }
        var reduce = function (collection, iteratee, initialValue) {
            if (iteratee === void 0) { iteratee = identity; }
            var initial = arguments.length >= 3;
            return reducer(collection, iteratee, initialValue, initial);
        };
        return reduce;
    }

    var reduce = createReduce(1);

    var reduceRight = createReduce(-1);

    var some = function (collection, predicate) {
        if (predicate === void 0) { predicate = identity; }
        var result = false;
        forEach(collection, function (item, index, arr) {
            if (predicate(item, index, arr)) {
                result = true;
                return false;
            }
        });
        return result;
    };

    var defaultTo = function (value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
    };

    var VERSION = "1.15.0";
    var isBrowser = typeof window !== stringUndefined && isObjectLike(window) && typeof document !== stringUndefined && isObjectLike(document) && window.document === document;
    var supportedArgumentsType = getTag((function () { return arguments; })()) === argumentsTag;
    var FUNC_ERROR_TEXT = 'Expected a function';
    function toSource(func) {
        if (func !== null) {
            try {
                return functionProtoToString.call(func);
            }
            catch (e) {
            }
            try {
                return func + '';
            }
            catch (e) {
            }
        }
        return '';
    }
    var stubFlase = function () { return false; };
    var stubTrue = function () { return true; };

    function after(n, func) {
        if (typeof func !== 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
        }
        n = defaultTo(toNumber(n), 0);
        return function () {
            if (--n < 1) {
                return func.apply(this, arguments);
            }
        };
    }

    function before(n, func) {
        if (typeof func !== 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
        }
        var result;
        n = defaultTo(toNumber(n), 0);
        return function () {
            if (--n > 0) {
                result = func.apply(this, arguments);
            }
            if (n <= 1) {
                func = nativeUndefined;
            }
            return result;
        };
    }

    function isUndefined(value) {
        return value === nativeUndefined;
    }

    var PLACEHOLDER$1 = {
        __ut2_curry_ph__: null
    };
    var curry = function (func, arity) {
        arity = isUndefined(arity) ? func.length : mathMax(toInteger(arity), 0);
        function wrap() {
            var args = arrayProtoSlice.call(arguments);
            var context = this;
            function inner() {
                var argsInner = arrayProtoSlice.call(arguments);
                for (var i = 0; i < args.length; i++) {
                    args[i] = args[i] === PLACEHOLDER$1 && argsInner.length > 0 ? argsInner.shift() : args[i];
                }
                args = args.concat(argsInner);
                var realArgsLength = args.filter(function (arg) { return arg !== PLACEHOLDER$1; }).length;
                if (realArgsLength >= arity) {
                    return func.apply(context, args);
                }
                return inner;
            }
            return inner();
        }
        return wrap;
    };
    curry.placeholder = curry._ = PLACEHOLDER$1;

    function baseDebounce(func, wait, immediate, __throttle__) {
        if (__throttle__ === void 0) { __throttle__ = false; }
        if (typeof func !== 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
        }
        var timer, lastCallTime, lastInvokeTime, lastArgs, lastThis, result;
        wait = defaultTo(toNumber(wait), 0);
        function shouldInvoke(time) {
            if (lastCallTime === nativeUndefined) {
                return true;
            }
            var timeSinceLastCall = time - lastCallTime;
            var timeSinceLastInvoke = time - lastInvokeTime;
            return timeSinceLastCall >= wait || timeSinceLastCall < 0 || (__throttle__ && timeSinceLastInvoke >= wait);
        }
        function invokeFunc(time) {
            lastInvokeTime = time;
            result = func.apply(lastThis, lastArgs);
            lastThis = lastArgs = nativeUndefined;
            return result;
        }
        function debounced() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            lastThis = this;
            lastArgs = args;
            var time = Date.now();
            var isInvoke = shouldInvoke(time);
            var waitTime = !__throttle__ ? wait : !isInvoke && lastCallTime !== nativeUndefined && timer === nativeUndefined ? wait - (time - lastCallTime) : wait;
            lastCallTime = time;
            if (isInvoke) {
                if (immediate && timer === nativeUndefined) {
                    return invokeFunc(time);
                }
            }
            if (timer !== nativeUndefined && !__throttle__) {
                clearTimeout(timer);
                timer = nativeUndefined;
            }
            if (timer === nativeUndefined) {
                timer = setTimeout(function () {
                    timer = nativeUndefined;
                    invokeFunc(Date.now());
                }, waitTime);
            }
            return result;
        }
        function cancel() {
            if (timer !== nativeUndefined) {
                clearTimeout(timer);
                timer = nativeUndefined;
            }
            lastCallTime = timer = lastArgs = lastThis = nativeUndefined;
        }
        function flush() {
            if (timer !== nativeUndefined) {
                clearTimeout(timer);
                timer = nativeUndefined;
                if (lastArgs) {
                    return invokeFunc(Date.now());
                }
            }
            return result;
        }
        function pending() {
            return timer !== nativeUndefined;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        debounced.pending = pending;
        return debounced;
    }

    function debounce(func, wait, immediate) {
        if (wait === void 0) { wait = 0; }
        if (immediate === void 0) { immediate = false; }
        return baseDebounce(func, wait, immediate);
    }

    function delay(func, wait) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (typeof func !== 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
        }
        var context = this;
        wait = defaultTo(toNumber(wait), 0);
        return setTimeout(function () {
            func.apply(context, args);
        }, wait);
    }

    function negate(predicate) {
        var _this = this;
        if (typeof predicate !== 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
        }
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return !predicate.apply(_this, args);
        };
    }

    function once(func) {
        return before(2, func);
    }

    var PLACEHOLDER = {
        __ut2_partial_ph__: null
    };
    var partial = function (func) {
        var argsOrig = arrayProtoSlice.call(arguments, 1);
        return function () {
            var args = [];
            var argsPartial = arrayProtoSlice.call(arguments);
            for (var i = 0; i < argsOrig.length; i++) {
                args[i] = argsOrig[i] === PLACEHOLDER ? argsPartial.shift() : argsOrig[i];
            }
            return func.apply(this, args.concat(argsPartial));
        };
    };
    partial.placeholder = partial._ = PLACEHOLDER;

    function throttle(func, wait, immediate) {
        if (wait === void 0) { wait = 0; }
        if (immediate === void 0) { immediate = true; }
        return baseDebounce(func, wait, immediate, true);
    }

    function isArguments(value) {
        if (supportedArgumentsType) {
            return getTag(value) === argumentsTag;
        }
        return isObjectLike(value) && objectProtoHasOwnProperty.call(value, 'callee') && !objectProtoPropertyIsEnumerable.call(value, 'callee');
    }

    var freeExports = typeof exports === stringObject && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module === stringObject && module && !module.nodeType && module;
    var nodeUtil = (function () {
        try {
            var types = freeModule && freeModule.require && freeModule.require('util').types;
            if (types) {
                return types;
            }
        }
        catch (e) {
        }
    })();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer;
    var nodeIsDate = nodeUtil && nodeUtil.isDate;
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    function isArrayBuffer(value) {
        return nodeIsArrayBuffer ? nodeIsArrayBuffer(value) : getTag(value) === arrayBufferTag;
    }

    function isBigInt(value) {
        return typeof value === 'bigint' || getTag(value) === bigIntTag;
    }

    var blobExisted = typeof Blob !== stringUndefined;
    function isBlob(value) {
        if (blobExisted && value instanceof Blob) {
            return true;
        }
        return getTag(value) === blobTag;
    }

    function isBoolean(value) {
        return value === true || value === false || getTag(value) === booleanTag;
    }

    function isBuffer(value) {
        if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function') {
            return Buffer.isBuffer(value);
        }
        return false;
    }

    var dataViewExisted = typeof DataView !== stringUndefined;
    var mapExisted = typeof Map !== stringUndefined;
    var promiseExisted = typeof Promise !== stringUndefined;
    var setExisted = typeof Set !== stringUndefined;
    var weakMapExisted = typeof WeakMap !== stringUndefined;
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map);
    var promiseCtorString = toSource(Promise);
    var setCtorString = toSource(Set);
    var weakMapCtorString = toSource(WeakMap);
    var getTagWithBugfix = getTag;
    if ((dataViewExisted && getTag(new DataView(new ArrayBuffer(1))) !== dataViewTag) ||
        (mapExisted && getTag(new Map()) !== mapTag) ||
        (promiseExisted && getTag(Promise.resolve()) !== promiseTag) ||
        (setExisted && getTag(new Set()) !== setTag) ||
        (weakMapExisted && getTag(new WeakMap()) !== weakMapTag)) {
        getTagWithBugfix = function (value) {
            var result = getTag(value);
            var Ctor = result === objectTag ? value.constructor : nativeUndefined;
            var ctorString = Ctor ? toSource(Ctor) : '';
            if (ctorString) {
                switch (ctorString) {
                    case dataViewCtorString:
                        return dataViewTag;
                    case mapCtorString:
                        return mapTag;
                    case promiseCtorString:
                        return promiseTag;
                    case setCtorString:
                        return setTag;
                    case weakMapCtorString:
                        return weakMapTag;
                }
            }
            return result;
        };
    }
    var getTagWithBugfix$1 = getTagWithBugfix;

    function isDataView(value) {
        return getTagWithBugfix$1(value) === dataViewTag;
    }

    function isDate(value) {
        return nodeIsDate ? nodeIsDate(value) : getTag(value) === dateTag;
    }

    var objectCtorString = functionProtoToString.call(Object);
    function isPlainObject(value) {
        if (!isObjectLike(value) || getTag(value) !== objectTag) {
            return false;
        }
        var proto = objectGetPrototypeOf(Object(value));
        if (proto === null) {
            return true;
        }
        var Ctor = objectProtoHasOwnProperty.call(proto, 'constructor') && proto.constructor;
        return typeof Ctor === 'function' && Ctor instanceof Ctor && functionProtoToString.call(Ctor) === objectCtorString;
    }

    function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    function isEmpty(value) {
        if (isNil(value)) {
            return true;
        }
        var tag = getTag(value);
        if (tag === mapTag || tag === setTag) {
            return !value.size;
        }
        if (isObjectLike(value)) {
            return !allKeys(value).length;
        }
        if (isArrayLike(value)) {
            return !value.length;
        }
        return true;
    }

    var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    function isTypedArray(value) {
        if (nodeIsTypedArray) {
            return nodeIsTypedArray(value);
        }
        if (isArrayLikeObject(value)) {
            return typedArrayPattern.test(getTag(value));
        }
        return false;
    }

    var symbolValueOf = symbolProto ? symbolProto.valueOf : nativeUndefined;
    function mapToArray(map) {
        var result = [];
        map.forEach(function (value, key) {
            result.push([key, value]);
        });
        return orderBy(result, [0, 1]);
    }
    function setToArray(set) {
        var result = [];
        set.forEach(function (value) {
            result.push(value);
        });
        return orderBy(result);
    }
    function argToArray(arg) {
        return arrayProtoSlice.call(arg);
    }
    function toBufferView(bufferSource) {
        return new Uint8Array(bufferSource.buffer || bufferSource, bufferSource.byteOffset || 0, bufferSource.byteLength);
    }
    function isDomNode(obj) {
        return isObjectLike(obj) && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string' && typeof obj.isEqualNode === 'function';
    }
    function isEqualDeep(value, other, customizer, strictCheck, valueStack, otherStack) {
        if (eq(value, other, strictCheck)) {
            return true;
        }
        var valType = typeof value;
        var othType = typeof other;
        if (strictCheck && valType !== othType) {
            return false;
        }
        if (isNil(value) || isNil(other) || (valType !== 'object' && othType !== 'object')) {
            return false;
        }
        var tag = getTagWithBugfix$1(value);
        if (tag !== getTagWithBugfix$1(other)) {
            return false;
        }
        var convert;
        switch (tag) {
            case numberTag:
                return eq(+value, +other, strictCheck);
            case booleanTag:
            case dateTag:
                return strictCheck ? +value === +other : eq(+value, +other);
            case stringTag:
            case regExpTag:
                return '' + value === '' + other;
            case symbolTag:
                return symbolValueOf ? symbolValueOf.call(value) === symbolValueOf.call(other) : false;
            case errorTag:
                return value.name === other.name && value.message === other.message;
            case dataViewTag:
            case arrayBufferTag:
                if (value.byteLength !== other.byteLength || (value.byteOffset && value.byteOffset !== other.byteOffset)) {
                    return false;
                }
                convert = toBufferView;
                break;
            case mapTag:
                convert = mapToArray;
                break;
            case setTag:
                convert = setToArray;
                break;
            case argumentsTag:
                convert = argToArray;
                break;
        }
        if (convert) {
            return isEqualDeep(convert(value), convert(other), customizer, strictCheck, valueStack, otherStack);
        }
        if (isDomNode(value) && isDomNode(other)) {
            return value.isEqualNode(other);
        }
        var areArrays = tag === arrayTag;
        if (!areArrays && isTypedArray(value)) {
            if (value.byteLength !== other.byteLength) {
                return false;
            }
            if (value.buffer === other.buffer && value.byteOffset === other.byteOffset) {
                return true;
            }
            areArrays = true;
        }
        if (isBuffer(value)) {
            if (!isBuffer(other)) {
                return false;
            }
            areArrays = true;
        }
        valueStack = valueStack || [];
        otherStack = otherStack || [];
        var length = valueStack.length;
        while (length--) {
            if (valueStack[length] === value) {
                return otherStack[length] === other;
            }
        }
        valueStack.push(value);
        otherStack.push(other);
        var result = true;
        var hasCustomizer = typeof customizer === 'function';
        if (areArrays) {
            length = value.length;
            if (length !== other.length) {
                return false;
            }
            while (length--) {
                if (hasCustomizer) {
                    var compared = customizer(value[length], other[length], length, value, other, valueStack, otherStack);
                    if (compared !== nativeUndefined) {
                        if (!compared) {
                            return false;
                        }
                        continue;
                    }
                }
                if (!isEqualDeep(value[length], other[length], customizer, strictCheck, valueStack, otherStack)) {
                    return false;
                }
            }
        }
        else if (tag === objectTag) {
            var keys = allKeys(value);
            length = keys.length;
            if (allKeys(other).length !== length) {
                return false;
            }
            var skipCtor = false;
            while (length--) {
                var key = keys[length];
                if (hasCustomizer) {
                    var compared = customizer(value[key], other[key], key, value, other, valueStack, otherStack);
                    if (compared !== nativeUndefined) {
                        if (!compared) {
                            return false;
                        }
                        continue;
                    }
                }
                if (!(objectProtoHasOwnProperty.call(other, key) && isEqualDeep(value[key], other[key], customizer, strictCheck, valueStack, otherStack))) {
                    return false;
                }
                if (!skipCtor && key === 'constructor') {
                    skipCtor = true;
                }
            }
            if (!skipCtor) {
                var valCtor = value.constructor;
                var othCtor = other.constructor;
                if (valCtor !== othCtor && !(isFunction(valCtor) && valCtor instanceof valCtor && isFunction(othCtor) && othCtor instanceof othCtor) && 'constructor' in value && 'constructor' in other) {
                    return false;
                }
            }
        }
        else {
            result = false;
        }
        valueStack.pop();
        otherStack.pop();
        return result;
    }

    function isEqual(value, other, customizer, strictCheck) {
        if (strictCheck === void 0) { strictCheck = false; }
        if (typeof customizer === 'function') {
            var result = customizer(value, other);
            if (result !== nativeUndefined) {
                return !!result;
            }
        }
        return isEqualDeep(value, other, customizer, strictCheck);
    }

    function isError(value) {
        if (!isObjectLike(value)) {
            return false;
        }
        if (value instanceof Error) {
            return true;
        }
        var tag = getTag(value);
        return tag === errorTag || tag === domExceptionTag;
    }

    var fileExisted = typeof File !== stringUndefined;
    function isFile(value) {
        if (fileExisted && value instanceof File) {
            return true;
        }
        return getTag(value) === fileTag;
    }

    var freeGlobalThis = globalThisExisted && globalThis.Object === Object && globalThis;
    var freeGlobal = globalExisted && global.Object === Object && global;
    var freeSelf = selfExisted && self.Object === Object && self;
    var root = freeGlobalThis || freeGlobal || freeSelf || Function('return this')();

    function isFinite(value) {
        return numberIsFinite ? numberIsFinite(value) : typeof value === 'number' && root.isFinite(value);
    }

    function isInteger(value) {
        return numberIsInteger ? numberIsInteger(value) : isFinite(value) && mathFloor(value) === value;
    }

    function isMap(value) {
        if (nodeIsMap) {
            return nodeIsMap(value);
        }
        return getTagWithBugfix$1(value) === mapTag;
    }

    function isDeepComparable(object, source) {
        return getTag(object) === objectTag && getTag(source) === objectTag;
    }
    function baseIsMatch(object, source, customizer, strictCheck, objStack, srcStack) {
        var hasCustomizer = typeof customizer === 'function';
        if (isDeepComparable(object, source)) {
            objStack = objStack || [];
            srcStack = srcStack || [];
            var stackLen = objStack.length;
            while (stackLen--) {
                if (objStack[stackLen] === object && srcStack[stackLen] === source) {
                    return true;
                }
            }
            objStack.push(object);
            srcStack.push(source);
            var keys = allKeys(source);
            var length_1 = keys.length;
            while (length_1--) {
                var key = keys[length_1];
                if (!(key in object)) {
                    return false;
                }
                if (hasCustomizer) {
                    var compared = customizer(object[key], source[key], key, object, source, objStack, srcStack);
                    if (compared !== nativeUndefined) {
                        if (!compared) {
                            return false;
                        }
                        continue;
                    }
                }
                if (!baseIsMatch(object[key], source[key], customizer, strictCheck, objStack, srcStack)) {
                    return false;
                }
            }
            objStack.pop();
            srcStack.pop();
            return true;
        }
        var result = isEqualDeep(object, source, function (objValue, srcValue, k, obj, src) {
            if (hasCustomizer) {
                var compared = customizer(objValue, srcValue, k, obj, src, objStack, srcStack);
                if (compared !== nativeUndefined) {
                    return compared;
                }
            }
            if (isDeepComparable(objValue, srcValue)) {
                return baseIsMatch(objValue, srcValue, customizer, strictCheck, objStack, srcStack);
            }
        }, strictCheck, objStack, srcStack);
        return result;
    }
    function isMatch(object, source, customizer, strictCheck) {
        if (strictCheck === void 0) { strictCheck = false; }
        if (typeof customizer === 'function') {
            var compared = customizer(object, source);
            if (compared !== nativeUndefined) {
                return !!compared;
            }
        }
        return baseIsMatch(object, source, customizer, strictCheck, nativeUndefined, nativeUndefined);
    }

    function isNaN(value) {
        return isNumber(value) && root.isNaN(value);
    }

    function isNull(value) {
        return value === null;
    }

    function isPromiseLike(value) {
        return isObject(value) && typeof value.then === 'function';
    }

    function isRegExp(value) {
        return nodeIsRegExp ? nodeIsRegExp(value) : getTag(value) === regExpTag;
    }

    function isSafeInteger(value) {
        return numberIsSafeInteger ? numberIsSafeInteger(value) : isInteger(value) && mathAbs(value) <= MAX_SAFE_INTEGER;
    }

    function isSet(value) {
        return nodeIsSet ? nodeIsSet(value) : getTagWithBugfix$1(value) === setTag;
    }

    function isString(value) {
        return typeof value === 'string' || getTag(value) === stringTag;
    }

    function isWeakMap(value) {
        return getTagWithBugfix$1(value) === weakMapTag;
    }

    function isWeakSet(value) {
        return getTag(value) === weakSetTag;
    }

    function isWindow(value) {
        return isObjectLike(value) && getTag(value) === windowTag;
    }

    function decimalAdjust(type, value, precision) {
        if (precision === void 0) { precision = 0; }
        var func = Math[type];
        value = toNumber(value);
        precision = mathMin(toInteger(precision), 292);
        if (precision === 0 || !isFinite(value)) {
            return func(value);
        }
        var pair = toString(value).split('e');
        value = func(+(pair[0] + 'e' + (pair[1] ? +pair[1] + precision : precision)));
        pair = toString(value).split('e');
        return +(pair[0] + 'e' + (pair[1] ? +pair[1] - precision : -precision));
    }

    function ceil(number, precision) {
        return decimalAdjust('ceil', number, precision);
    }

    function floor(number, precision) {
        return decimalAdjust('floor', number, precision);
    }

    function createOperation(comparator) {
        return function (value, other) {
            if (!(typeof value === 'string' && typeof other === 'string')) {
                value = toNumber(value);
                other = toNumber(other);
            }
            return comparator(value, other);
        };
    }
    var baseGt = function (value, other) {
        return value > other;
    };
    var baseGte = function (value, other) {
        return value >= other;
    };
    var baseLt = function (value, other) {
        return value < other;
    };
    var baseLte = function (value, other) {
        return value <= other;
    };

    function createExtremum(array, comparator, iteratee) {
        if (!isArray(array)) {
            return;
        }
        var result, computed;
        var internalIteratee = createIteratee(iteratee);
        array.forEach(function (value, index) {
            var current = internalIteratee(value, index, array);
            if (current != null && (computed === nativeUndefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
                computed = current;
                result = value;
            }
        });
        return result;
    }

    var max = function (array, iteratee) {
        return createExtremum(array, baseGt, iteratee);
    };

    var min = function (array, iteratee) {
        return createExtremum(array, baseLt, iteratee);
    };

    function round(number, precision) {
        return decimalAdjust('round', number, precision);
    }

    var clamp = function (number, lower, upper) {
        if (upper === nativeUndefined) {
            upper = lower;
            lower = nativeUndefined;
        }
        if (upper !== nativeUndefined) {
            upper = defaultTo(toNumber(upper), 0);
        }
        if (lower !== nativeUndefined) {
            lower = defaultTo(toNumber(lower), 0);
        }
        number = toNumber(number);
        if (number === number) {
            if (upper !== nativeUndefined) {
                number = number <= upper ? number : upper;
            }
            if (lower !== nativeUndefined) {
                number = number >= lower ? number : lower;
            }
        }
        return number;
    };

    function inRange(number, start, end) {
        if (end === void 0) { end = 0; }
        number = toNumber(number);
        start = toNumber(start);
        end = toNumber(end);
        return number >= mathMin(start, end) && number < mathMax(start, end);
    }

    function random(lower, upper) {
        if (lower === void 0) { lower = 0; }
        if (upper === void 0) { upper = 1; }
        lower = toFinite(lower);
        upper = toFinite(upper);
        var min = mathMin(lower, upper);
        var max = mathMax(lower, upper);
        return min + mathRandom() * (max - min);
    }

    function getKeysIn(object) {
        var result = [];
        for (var key in object) {
            result.push(key);
        }
        return result;
    }

    function getSymbolsIn(object) {
        var result = [];
        var o = Object(object);
        while (o) {
            getSymbols(o).forEach(function (item) {
                if (result.indexOf(item) === -1) {
                    result.push(item);
                }
            });
            o = objectGetPrototypeOf(o);
        }
        return result;
    }

    function allKeysIn(object) {
        if (!isObject(object)) {
            return [];
        }
        return getKeysIn(object).concat(getSymbolsIn(object));
    }

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol, Iterator */


    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
        return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    var findKey = function (obj, predicate) {
        var e_1, _a;
        if (predicate === void 0) { predicate = stubFlase; }
        var key;
        if (isMap(obj)) {
            try {
                for (var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()) {
                    var _b = __read(obj_1_1.value, 2), k = _b[0], v = _b[1];
                    if (predicate(v, k)) {
                        key = k;
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else if (isObject(obj)) {
            forEach(obj, function (v, k) {
                if (predicate(v, k)) {
                    key = k;
                    return false;
                }
            });
        }
        return key;
    };

    function invert(object, predicate) {
        if (predicate === void 0) { predicate = stubTrue; }
        var _keys = allKeys(object);
        var result = {};
        _keys.forEach(function (key) {
            var value = object[key];
            if (predicate(value, key)) {
                var valueProp = value != null && typeof value.toString != 'function' ? objectProtoToString.call(value) : value;
                result[valueProp] = key;
            }
            else {
                result[key] = value;
            }
        });
        return result;
    }

    function keys(object) {
        if (!isObject(object)) {
            return [];
        }
        return objectKeys(object);
    }

    function keysIn(object) {
        if (!isObject(object)) {
            return [];
        }
        return getKeysIn(object);
    }

    function baseMerge(object, source, getKeys, customizer, stack) {
        if (stack === void 0) { stack = new WeakMap(); }
        var obj = Object(object);
        if (!isObject(source) || obj === source) {
            return obj;
        }
        var keys = getKeys(source);
        var hasCustomizer = typeof customizer === 'function';
        keys.forEach(function (key) {
            var srcValue = source[key];
            var srcIsObj = isObject(srcValue);
            if (srcIsObj && stack.has(srcValue)) {
                obj[key] = srcValue;
            }
            else {
                var newValue = hasCustomizer ? customizer(obj[key], srcValue, key, obj, source) : nativeUndefined;
                if (newValue !== nativeUndefined) {
                    obj[key] = newValue;
                }
                else {
                    var objValue = obj[key];
                    var newObjValue = void 0;
                    if (srcIsObj) {
                        stack.set(srcValue, true);
                        if (isArray(srcValue)) {
                            newObjValue = isArray(objValue) ? objValue : [];
                        }
                        else if (isPlainObject(srcValue)) {
                            newObjValue = isObjectLike(objValue) ? objValue : {};
                        }
                    }
                    if (newObjValue) {
                        obj[key] = baseMerge(newObjValue, srcValue, getKeys, customizer, stack);
                    }
                    else if (srcValue !== nativeUndefined || !(key in obj)) {
                        obj[key] = srcValue;
                    }
                }
            }
        });
        return obj;
    }
    function merge(object, source, customizer, getKeys) {
        if (getKeys === void 0) { getKeys = allKeys; }
        return baseMerge(object, source, getKeys, customizer);
    }
    merge.NOT_MERGE_ARRAYS = function (objValue, srcValue) { return (isArray(srcValue) ? srcValue : undefined); };

    var mergeObject = function (object, source) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (args.length > 0) {
            var _a = __read(args), arg1 = _a[0], restArgs = _a.slice(1);
            var obj = merge(object, source, merge.NOT_MERGE_ARRAYS);
            return mergeObject.apply(void 0, __spreadArray([obj, arg1], __read(restArgs), false));
        }
        return merge(object, source, merge.NOT_MERGE_ARRAYS);
    };

    function castArray(value) {
        if (!arguments.length) {
            return [];
        }
        return isArray(value) ? value : [value];
    }

    function omit(object, fields) {
        if (fields === void 0) { fields = []; }
        var keys = allKeysIn(object);
        var fieldArr = castArray(fields);
        var result = {};
        keys.forEach(function (key) {
            if (fieldArr.indexOf(key) === -1) {
                result[key] = object[key];
            }
        });
        return result;
    }

    function pickBy(object, predicate) {
        if (predicate === void 0) { predicate = stubFlase; }
        var result = {};
        var keys = allKeysIn(object);
        keys.forEach(function (key) {
            if (predicate(object[key], key)) {
                result[key] = object[key];
            }
        });
        return result;
    }

    function omitBy(object, predicate) {
        if (predicate === void 0) { predicate = stubFlase; }
        return pickBy(object, negate(predicate));
    }

    function pick(object, fields) {
        if (fields === void 0) { fields = []; }
        var result = {};
        if (!isObject(object)) {
            return result;
        }
        var fieldArr = castArray(fields);
        fieldArr.forEach(function (field) {
            if (field in object) {
                result[field] = object[field];
            }
        });
        return result;
    }

    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function words(string, pattern) {
        if (pattern === void 0) { pattern = reAsciiWord; }
        return string.match(pattern) || [];
    }

    function splitCaseWords(string, pattern) {
        return words(toString(string).replace(/['\u2019]/g, ''), pattern);
    }

    function createCaseFirst(methodName) {
        return function (string) {
            var str = toString(string);
            if (!str) {
                return '';
            }
            return str[0][methodName]() + str.slice(1);
        };
    }

    var upperFirst = createCaseFirst('toUpperCase');

    function camelCase(string, pattern) {
        return splitCaseWords(string, pattern).reduce(function (prev, cur, index) {
            cur = cur.toLowerCase();
            return prev + (index ? upperFirst(cur) : cur);
        }, '');
    }

    function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
    }

    var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
    };
    var reUnescapedHtml = /[&<>"']/g;
    var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    function escape(string) {
        string = toString(string);
        return string && reHasUnescapedHtml.test(string)
            ? string.replace(reUnescapedHtml, function (chr) {
                return htmlEscapes[chr];
            })
            : string || '';
    }

    var reRegExpChar = /[\\^$.*+?\-()[\]{}|]/g;
    var reHasRegExpChar = RegExp(reRegExpChar.source);
    function escapeRegExp(string) {
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string || '';
    }

    function kebabCase(string, pattern) {
        return splitCaseWords(string, pattern).reduce(function (prev, cur, index) { return prev + (index ? '-' : '') + cur.toLowerCase(); }, '');
    }

    function lowerCase(string, pattern) {
        return splitCaseWords(string, pattern).reduce(function (prev, cur, index) { return prev + (index ? ' ' : '') + cur.toLowerCase(); }, '');
    }

    var lowerFirst = createCaseFirst('toLowerCase');

    function pascalCase(string, pattern) {
        return splitCaseWords(string, pattern).reduce(function (prev, cur) {
            cur = cur.toLowerCase();
            return prev + upperFirst(cur);
        }, '');
    }

    function snakeCase(string, pattern) {
        return splitCaseWords(string, pattern).reduce(function (prev, cur, index) { return prev + (index ? '_' : '') + cur.toLowerCase(); }, '');
    }

    var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'"
    };
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#(0+)?39);/g;
    var reHasEscapedHtml = RegExp(reEscapedHtml.source);
    function unescape(string) {
        string = toString(string);
        return string && reHasEscapedHtml.test(string)
            ? string.replace(reEscapedHtml, function (chr) {
                return htmlUnescapes[chr] || "'";
            })
            : string || '';
    }

    function upperCase(string, pattern) {
        return splitCaseWords(string, pattern).reduce(function (prev, cur, index) { return prev + (index ? ' ' : '') + cur.toUpperCase(); }, '');
    }

    var conformsTo = function (object, source) {
        var props = allKeys(source);
        var length = props.length;
        if (isNil(object)) {
            return !length;
        }
        if (length === 0) {
            return true;
        }
        for (var i = 0; i < length; i++) {
            var key = props[i];
            var predicate = source[key];
            var value = object[key];
            if ((value === nativeUndefined && !(key in object)) || !predicate(value)) {
                return false;
            }
        }
        return true;
    };

    var conforms = function (source) {
        return function (object) {
            return conformsTo(object, source);
        };
    };

    function constant(value) {
        return function () {
            return value;
        };
    }

    var gt = createOperation(baseGt);

    var gte = createOperation(baseGte);

    var guard = function (fn, shouldGuard) {
        var _guard = function (err) {
            if (shouldGuard && !shouldGuard(err)) {
                throw err;
            }
            return undefined;
        };
        try {
            var result = fn();
            return isPromiseLike(result) ? result.catch(_guard) : result;
        }
        catch (err) {
            return _guard(err);
        }
    };

    var list = function (n, iteratee) {
        if (iteratee === void 0) { iteratee = identity; }
        if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
        }
        var index = 0;
        var length = mathMin(isInteger(n) ? n : mathFloor(isFinite(n) ? n : 0), MAX_ARRAY_LENGTH);
        var result = Array(length);
        var func = typeof iteratee === 'function' ? iteratee : identity;
        while (index < length) {
            result[index] = func(index);
            index++;
        }
        return result;
    };

    var lt = createOperation(baseLt);

    var lte = createOperation(baseLte);

    function noop() { }

    function nthArg(n) {
        if (n === void 0) { n = 0; }
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return nth(args, n);
        };
    }

    var range = function (start, end, step) {
        start = toFinite(start);
        if (isNil(end)) {
            end = start;
            start = 0;
        }
        else {
            end = toFinite(end);
        }
        step = toFinite(step);
        if (!step) {
            step = start < end ? 1 : -1;
        }
        var index = -1;
        var length = mathMax(mathCeil((end - start) / step), 0);
        var result = Array(length);
        while (length--) {
            result[++index] = start;
            start += step;
        }
        return result;
    };

    function sleep(ms) {
        if (ms === void 0) { ms = 1000; }
        return new Promise(function (resolve) {
            setTimeout(resolve, ms);
        });
    }

    var tryit = function (fn) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                var result = fn.apply(void 0, __spreadArray([], __read(args), false));
                if (isPromiseLike(result)) {
                    return result
                        .then(function (res) {
                        return [null, res];
                    })
                        .catch(function (err) {
                        return [err, nativeUndefined];
                    });
                }
                return [null, result];
            }
            catch (err) {
                return [err, nativeUndefined];
            }
        };
    };

    function retry(fn, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, times, delay, backoff, exit, i, _c, err, result;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _a = options || {}, _b = _a.times, times = _b === void 0 ? 3 : _b, delay = _a.delay, backoff = _a.backoff, exit = _a.exit;
                        i = 1;
                        _d.label = 1;
                    case 1:
                        if (!(i <= times)) return [3, 7];
                        return [4, tryit(fn)()];
                    case 2:
                        _c = __read.apply(void 0, [_d.sent(), 2]), err = _c[0], result = _c[1];
                        if (!err)
                            return [2, result];
                        if ((exit && exit(err, i)) || i === times)
                            throw err;
                        if (!delay) return [3, 4];
                        return [4, sleep(delay)];
                    case 3:
                        _d.sent();
                        _d.label = 4;
                    case 4:
                        if (!backoff) return [3, 6];
                        return [4, sleep(backoff(i))];
                    case 5:
                        _d.sent();
                        _d.label = 6;
                    case 6:
                        i++;
                        return [3, 1];
                    case 7: return [2];
                }
            });
        });
    }

    var times = list;

    function toSafeInteger(value) {
        if (!value) {
            return value === 0 ? value : 0;
        }
        value = toInteger(value);
        if (value > MAX_SAFE_INTEGER) {
            return MAX_SAFE_INTEGER;
        }
        if (value < MIN_SAFE_INTEGER) {
            return MIN_SAFE_INTEGER;
        }
        return value;
    }

    var idCounter = 0;
    var defaultPrefix = '_' + mathRandom().toString(36).substring(2, 4);
    function uniqueId(prefix) {
        if (prefix === void 0) { prefix = defaultPrefix; }
        return '' + prefix + ++idCounter;
    }

    exports.MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH;
    exports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
    exports.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;
    exports.VERSION = VERSION;
    exports.after = after;
    exports.allKeys = allKeys;
    exports.allKeysIn = allKeysIn;
    exports.before = before;
    exports.camelCase = camelCase;
    exports.capitalize = capitalize;
    exports.castArray = castArray;
    exports.ceil = ceil;
    exports.chunk = chunk;
    exports.clamp = clamp;
    exports.compact = compact;
    exports.conforms = conforms;
    exports.conformsTo = conformsTo;
    exports.constant = constant;
    exports.countBy = countBy;
    exports.curry = curry;
    exports.debounce = debounce;
    exports.defaultTo = defaultTo;
    exports.delay = delay;
    exports.difference = difference;
    exports.eq = eq;
    exports.escape = escape;
    exports.escapeRegExp = escapeRegExp;
    exports.every = every;
    exports.filter = filter;
    exports.find = find;
    exports.findKey = findKey;
    exports.floor = floor;
    exports.forEach = forEach;
    exports.forEachRight = forEachRight;
    exports.fromPairs = fromPairs;
    exports.groupBy = groupBy;
    exports.gt = gt;
    exports.gte = gte;
    exports.guard = guard;
    exports.identity = identity;
    exports.inRange = inRange;
    exports.intersection = intersection;
    exports.invert = invert;
    exports.isArguments = isArguments;
    exports.isArray = isArray;
    exports.isArrayBuffer = isArrayBuffer;
    exports.isArrayLike = isArrayLike;
    exports.isArrayLikeObject = isArrayLikeObject;
    exports.isBigInt = isBigInt;
    exports.isBlob = isBlob;
    exports.isBoolean = isBoolean;
    exports.isBrowser = isBrowser;
    exports.isBuffer = isBuffer;
    exports.isDataView = isDataView;
    exports.isDate = isDate;
    exports.isElement = isElement;
    exports.isEmpty = isEmpty;
    exports.isEqual = isEqual;
    exports.isError = isError;
    exports.isFile = isFile;
    exports.isFinite = isFinite;
    exports.isFunction = isFunction;
    exports.isInteger = isInteger;
    exports.isLength = isLength;
    exports.isMap = isMap;
    exports.isMatch = isMatch;
    exports.isNaN = isNaN;
    exports.isNil = isNil;
    exports.isNull = isNull;
    exports.isNumber = isNumber;
    exports.isObject = isObject;
    exports.isObjectLike = isObjectLike;
    exports.isPlainObject = isPlainObject;
    exports.isPromiseLike = isPromiseLike;
    exports.isRegExp = isRegExp;
    exports.isSafeInteger = isSafeInteger;
    exports.isSet = isSet;
    exports.isString = isString;
    exports.isSymbol = isSymbol;
    exports.isTypedArray = isTypedArray;
    exports.isUndefined = isUndefined;
    exports.isWeakMap = isWeakMap;
    exports.isWeakSet = isWeakSet;
    exports.isWindow = isWindow;
    exports.kebabCase = kebabCase;
    exports.keyBy = keyBy;
    exports.keys = keys;
    exports.keysIn = keysIn;
    exports.list = list;
    exports.lowerCase = lowerCase;
    exports.lowerFirst = lowerFirst;
    exports.lt = lt;
    exports.lte = lte;
    exports.map = map;
    exports.max = max;
    exports.merge = merge;
    exports.mergeObject = mergeObject;
    exports.min = min;
    exports.move = move;
    exports.negate = negate;
    exports.noop = noop;
    exports.nth = nth;
    exports.nthArg = nthArg;
    exports.omit = omit;
    exports.omitBy = omitBy;
    exports.once = once;
    exports.orderBy = orderBy;
    exports.partial = partial;
    exports.partition = partition;
    exports.pascalCase = pascalCase;
    exports.pick = pick;
    exports.pickBy = pickBy;
    exports.random = random;
    exports.randomInt = randomInt;
    exports.range = range;
    exports.reduce = reduce;
    exports.reduceRight = reduceRight;
    exports.retry = retry;
    exports.root = root;
    exports.round = round;
    exports.shuffle = shuffle;
    exports.sleep = sleep;
    exports.snakeCase = snakeCase;
    exports.some = some;
    exports.throttle = throttle;
    exports.times = times;
    exports.toFinite = toFinite;
    exports.toInteger = toInteger;
    exports.toLength = toLength;
    exports.toNumber = toNumber;
    exports.toSafeInteger = toSafeInteger;
    exports.toString = toString;
    exports.tryit = tryit;
    exports.unescape = unescape;
    exports.union = union;
    exports.uniq = uniq;
    exports.uniqueId = uniqueId;
    exports.unzip = unzip;
    exports.upperCase = upperCase;
    exports.upperFirst = upperFirst;
    exports.words = words;
    exports.xor = xor;
    exports.zip = zip;

}));
//# sourceMappingURL=ut2.js.map
