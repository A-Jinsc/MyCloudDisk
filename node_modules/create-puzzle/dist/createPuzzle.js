(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.createPuzzle = {}));
})(this, (function (exports) { 'use strict';

    var stringUndefined = 'undefined';
    var objectProto = Object.prototype;
    var objectProtoToString = objectProto.toString;
    var mathMin = Math.min;
    var mathMax = Math.max;
    var mathRandom = Math.random;
    var mathFloor = Math.floor;
    var mathCeil = Math.ceil;
    var stringTag = '[object String]';
    var symbolTag = '[object Symbol]';
    var blobTag = '[object Blob]';

    function isObjectLike(value) {
        return value !== null && typeof value === 'object';
    }

    function isObject(value) {
        return typeof value === 'function' || isObjectLike(value);
    }

    function getTag(value) {
        return objectProtoToString.call(value);
    }

    function isSymbol(value) {
        return typeof value === 'symbol' || getTag(value) === symbolTag;
    }

    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    function toNumber(value) {
        if (typeof value === 'number') {
            return value;
        }
        if (isSymbol(value)) {
            return NaN;
        }
        if (isObject(value)) {
            value = Number(value);
        }
        if (typeof value !== 'string') {
            return value === 0 ? value : +value;
        }
        value = value.trim();
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? parseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NaN : +value;
    }

    var MAX_VALUE = 1.7976931348623157e308;
    function toFinite(value) {
        if (!value) {
            return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === Infinity || value === -Infinity) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_VALUE;
        }
        return value === value ? value : 0;
    }

    function randomInt(lower, upper) {
        if (lower === void 0) { lower = 0; }
        if (upper === void 0) { upper = 1; }
        lower = toFinite(lower);
        upper = toFinite(upper);
        var min = mathCeil(mathMin(lower, upper) || 0);
        var max = mathFloor(mathMax(lower, upper) || 0);
        if (min > max) {
            var temp = min;
            min = max;
            max = temp;
        }
        return mathFloor(min + mathRandom() * (max - min + 1));
    }

    var blobExisted = typeof Blob !== stringUndefined;
    function isBlob(value) {
        if (blobExisted && value instanceof Blob) {
            return true;
        }
        return getTag(value) === blobTag;
    }

    function isString(value) {
        return typeof value === 'string' || getTag(value) === stringTag;
    }

    function constant(value) {
        return function () {
            return value;
        };
    }

    function noop() { }

    var idCounter = 0;
    var defaultPrefix$1 = '_' + mathRandom().toString(36).substring(2, 4);
    function uniqueId(prefix) {
        if (prefix === void 0) { prefix = defaultPrefix$1; }
        return '' + prefix + ++idCounter;
    }

    var URLExisted = typeof URL !== 'undefined';

    var objectKeys = Object.keys;
    var createObjectURL = URLExisted ? URL.createObjectURL : constant('');
    var revokeObjectURL = URLExisted ? URL.revokeObjectURL : noop;

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    function ajax(url, options) {
        var _a = options || {}, _b = _a.method, method = _b === void 0 ? 'get' : _b, _c = _a.data, data = _c === void 0 ? null : _c, timeout = _a.timeout, headers = _a.headers, _d = _a.withCredentials, withCredentials = _d === void 0 ? false : _d, _e = _a.async, async = _e === void 0 ? true : _e, _f = _a.user, user = _f === void 0 ? null : _f, _g = _a.password, password = _g === void 0 ? null : _g, responseType = _a.responseType, onReadyStateChange = _a.onReadyStateChange, onLoadStart = _a.onLoadStart, onProgress = _a.onProgress, onAbort = _a.onAbort, onTimeout = _a.onTimeout, onError = _a.onError, onLoad = _a.onLoad, onLoadEnd = _a.onLoadEnd;
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open(method.toLowerCase(), url, async, user, password);
            if (onReadyStateChange) {
                xhr.onreadystatechange = onReadyStateChange;
            }
            if (typeof timeout === 'number' && timeout > 0) {
                xhr.timeout = timeout;
            }
            xhr.withCredentials = withCredentials;
            if (responseType) {
                xhr.responseType = responseType;
            }
            if (typeof headers === 'object') {
                objectKeys(headers).map(function (item) {
                    xhr.setRequestHeader(item, headers[item]);
                });
            }
            var wrapSuccess = function (cb) {
                return function (e) {
                    resolve(e);
                    cb === null || cb === void 0 ? void 0 : cb.call(xhr, e);
                };
            };
            var wrapError = function (cb) {
                return function (e) {
                    reject(e);
                    cb === null || cb === void 0 ? void 0 : cb.call(xhr, e);
                };
            };
            var events = {
                loadstart: onLoadStart,
                progress: onProgress,
                abort: wrapError(onAbort),
                timeout: wrapError(onTimeout),
                error: wrapError(onError),
                load: wrapSuccess(onLoad),
                loadend: onLoadEnd
            };
            var eventKeys = objectKeys(events);
            eventKeys.map(function (item) {
                var func = events[item];
                if (func) {
                    xhr.addEventListener(item, func);
                }
            });
            xhr.send(data);
        });
    }

    var SuccessResponseStatus = [200, 304];
    function getFileBlob(file, ajaxOptions) {
        return new Promise(function (resolve, reject) {
            if (isBlob(file)) {
                resolve(file);
            }
            else {
                ajax(file, __assign({ responseType: 'blob' }, ajaxOptions))
                    .then(function (ev) {
                    var responseStatus = ev.target.status;
                    if (SuccessResponseStatus.indexOf(responseStatus) !== -1) {
                        resolve(ev.target.response);
                    }
                    else {
                        var err = new Error("The file does not support get requests, responseStatus ".concat(responseStatus, ", '").concat(file, "'."));
                        console.error(err);
                        reject(err);
                    }
                })
                    .catch(function (err) {
                    console.error(new Error("Failed to request file. ".concat(err)));
                    reject(err);
                });
            }
        });
    }

    function loadImage(img) {
        return new Promise(function (resolve, reject) {
            var imgIsBlob = isBlob(img);
            var url = imgIsBlob ? createObjectURL(img) : img;
            var image = new Image();
            if (!imgIsBlob) {
                image.crossOrigin = 'anonymous';
            }
            image.onload = function () {
                resolve(image);
            };
            image.onerror = function (err) {
                if (imgIsBlob) {
                    revokeObjectURL(url);
                }
                console.error("[loadImage] The image load failed, '".concat(img, "'."));
                reject(err);
            };
            image.src = url;
        });
    }

    function loadImageWithBlob(img, ajaxOptions) {
        return getFileBlob(img, ajaxOptions).then(function (blob) {
            return loadImage(blob).then(function (image) {
                return { blob: blob, image: image };
            });
        });
    }

    var EmitterPro = /** @class */ (function () {
        function EmitterPro() {
            this.handlers = {};
        }
        EmitterPro.prototype.eventNames = function () {
            var _a;
            var symbols = ((_a = Object.getOwnPropertySymbols) === null || _a === void 0 ? void 0 : _a.call(Object, this.handlers)) || [];
            var keys = Object.keys(this.handlers);
            return keys.concat(symbols);
        };
        EmitterPro.prototype.rawListeners = function (eventName) {
            var handler = this.handlers[eventName];
            return handler ? handler.map(function (item) { return item.raw; }) : [];
        };
        EmitterPro.prototype.listeners = function (eventName) {
            var handler = this.handlers[eventName];
            return handler ? handler.map(function (item) { return item.wrap; }) : [];
        };
        EmitterPro.prototype.hasListener = function (eventName, listener) {
            return this.rawListeners(eventName).some(function (item) { return item === listener; });
        };
        EmitterPro.prototype._on = function (eventName, raw, wrap, context, dir) {
            if (context === void 0) { context = null; }
            if (dir === void 0) { dir = 1; }
            var currentListener = { raw: raw, wrap: wrap, context: context };
            if (!this.handlers[eventName]) {
                this.handlers[eventName] = [currentListener];
            }
            else {
                var appendMethod = dir === 1 ? 'push' : 'unshift';
                this.handlers[eventName][appendMethod](currentListener);
            }
            return this;
        };
        EmitterPro.prototype.prependListener = function (eventName, listener, context) {
            return this._on(eventName, listener, listener, context, 0);
        };
        EmitterPro.prototype.on = function (eventName, listener, context) {
            return this._on(eventName, listener, listener, context);
        };
        EmitterPro.prototype._wrapOnce = function (eventName, listener, context) {
            var _this = this;
            if (context === void 0) { context = null; }
            var wrap = (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                listener.apply(context, args);
                _this.off(eventName, wrap);
            });
            return wrap;
        };
        EmitterPro.prototype.once = function (eventName, listener, context) {
            var wrap = this._wrapOnce(eventName, listener, context);
            return this._on(eventName, listener, wrap, context);
        };
        EmitterPro.prototype.prependOnceListener = function (eventName, listener, context) {
            var wrap = this._wrapOnce(eventName, listener, context);
            return this._on(eventName, listener, wrap, context, 0);
        };
        EmitterPro.prototype.off = function (eventName, listener) {
            var handler = this.handlers[eventName];
            if (handler) {
                if (listener) {
                    var index = handler.findIndex(function (item) { return item.wrap === listener || item.raw === listener; });
                    if (index !== -1) {
                        handler.splice(index, 1);
                    }
                }
                else {
                    delete this.handlers[eventName];
                }
            }
            return this;
        };
        EmitterPro.prototype.offAll = function () {
            this.handlers = {};
            return this;
        };
        EmitterPro.prototype.emit = function (eventName) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var handler = this.handlers[eventName];
            if (handler && handler.length > 0) {
                handler.forEach(function (listener) {
                    listener.wrap.apply(listener.context, args);
                });
                return true;
            }
            return false;
        };
        return EmitterPro;
    }());

    // 随机字符串
    function randomString() {
        return Math.random().toString(16).substring(2, 8);
    }
    // 内部自增id
    var uid = 1;
    // 返回唯一标识
    function getUniqueId() {
        return "".concat(randomString(), "_").concat(uid++);
    }
    // 是否支持 storage
    function isStorageSupported(storage) {
        try {
            var isSupport = typeof storage === 'object' &&
                storage !== null &&
                !!storage.setItem &&
                !!storage.getItem &&
                !!storage.removeItem;
            if (isSupport) {
                var key = getUniqueId();
                var value = '1';
                storage.setItem(key, value);
                if (storage.getItem(key) !== value) {
                    return false;
                }
                storage.removeItem(key);
            }
            return isSupport;
        }
        catch (e) {
            console.error("[cache2] ".concat(storage, " is not supported. The default memory cache will be used."));
            return false;
        }
    }
    function parse(value, reviver) {
        try {
            return JSON.parse(value, reviver);
        }
        catch (e) {
            return value;
        }
    }
    function stringify(value, replacer) {
        return JSON.stringify(value, replacer);
    }

    var cache = {};
    var MemoryStorage = /** @class */ (function () {
        function MemoryStorage(scope) {
            if (scope === void 0) { scope = 'default'; }
            this.scope = scope;
            if (!cache[this.scope]) {
                cache[this.scope] = {};
            }
            this.data = cache[this.scope];
        }
        MemoryStorage.prototype.getItem = function (key) {
            return key in this.data ? this.data[key] : null;
        };
        MemoryStorage.prototype.setItem = function (key, value) {
            this.data[key] = value;
        };
        MemoryStorage.prototype.removeItem = function (key) {
            delete this.data[key];
        };
        MemoryStorage.prototype.clear = function () {
            cache[this.scope] = {};
            this.data = cache[this.scope];
        };
        return MemoryStorage;
    }());

    var Storage = /** @class */ (function () {
        function Storage(storage, options) {
            if (options === void 0) { options = {}; }
            var isSupported = storage ? isStorageSupported(storage) : false;
            this.options = __assign({ needParsed: isSupported }, options);
            this.storage = isSupported ? storage : new MemoryStorage(this.options.memoryScope);
        }
        Storage.prototype.get = function (key) {
            var data = this.storage.getItem(key);
            return this.options.needParsed ? parse(data, this.options.reviver) : data;
        };
        Storage.prototype.set = function (key, data) {
            this.storage.setItem(key, this.options.needParsed ? stringify(data, this.options.replacer) : data);
        };
        Storage.prototype.del = function (key) {
            this.storage.removeItem(key);
        };
        Storage.prototype.clear = function () {
            if (typeof this.storage.clear === 'function') {
                this.storage.clear();
            }
        };
        return Storage;
    }());

    var defaultPrefix = 'cache2_'; // 命名空间缓存键前缀，默认 cache2_ 。
    var defaultNamespace = 'default';
    var Cache = /** @class */ (function (_super) {
        __extends(Cache, _super);
        function Cache(namespace, options) {
            var _this = _super.call(this) || this;
            var ns = defaultNamespace, opts;
            if (typeof namespace === 'string') {
                ns = namespace;
            }
            else if (typeof namespace === 'object') {
                opts = namespace;
            }
            if (!opts && typeof options === 'object') {
                opts = options;
            }
            _this.options = __assign({ max: -1, stdTTL: 0, maxStrategy: 'limited', checkperiod: 0, prefix: defaultPrefix }, opts);
            _this.storage = new Storage(_this.options.storage, __assign({ memoryScope: ns }, opts));
            _this.cacheKey = (_this.options.prefix || '') + (ns || '') || getUniqueId();
            _this.startCheckperiod();
            return _this;
        }
        // 检查当前键值是否过期，如果过期将会自动删除
        Cache.prototype._check = function (key, data) {
            var ret = true;
            if (data.t !== 0 && data.t < Date.now()) {
                ret = false;
                this.del(key);
                this.emit('expired', key, data.v);
            }
            return ret;
        };
        Cache.prototype._wrap = function (value, ttl) {
            var now = Date.now();
            var currentTtl = typeof ttl === 'number' ? ttl : this.options.stdTTL;
            var livetime = currentTtl > 0 ? now + currentTtl : 0;
            return {
                v: value,
                t: livetime,
                n: now
            };
        };
        Cache.prototype._isLimited = function (len) {
            return this.options.max > -1 && len >= this.options.max;
        };
        Cache.prototype._getReplaceKey = function (keys, cacheValues) {
            var retkey = keys[0];
            keys.forEach(function (key) {
                if (cacheValues[key].t < cacheValues[retkey].t ||
                    (cacheValues[key].t === cacheValues[retkey].t && cacheValues[key].n < cacheValues[retkey].n)) {
                    retkey = key;
                }
            });
            return retkey;
        };
        Object.defineProperty(Cache.prototype, "cacheValues", {
            // 获取全部缓存数据，不处理过期数据和排序
            get: function () {
                return this.storage.get(this.cacheKey) || {};
            },
            enumerable: false,
            configurable: true
        });
        // 设置缓存数据
        Cache.prototype.setCacheValues = function (values) {
            this.storage.set(this.cacheKey, values);
        };
        // 从缓存中获取保存的值。如果未找到或已过期，则返回 undefined 。如果找到该值，则返回该值。
        Cache.prototype.get = function (key) {
            var data = this.cacheValues[key];
            if (data && this._check(key, data)) {
                return data.v;
            }
            return;
        };
        // 从缓存中获取多个保存的值。如果未找到或已过期，则返回一个空对象。如果找到该值，它会返回一个具有键值对的对象。
        Cache.prototype.mget = function (keys) {
            var _this = this;
            var ret = {};
            if (!Array.isArray(keys)) {
                return ret;
            }
            var cacheValues = this.cacheValues;
            keys.forEach(function (key) {
                var data = cacheValues[key];
                if (data && _this._check(key, data)) {
                    ret[key] = data.v;
                }
            });
            return ret;
        };
        // 从缓存中获取全部保存的值。返回一个具有键值对的对象。
        Cache.prototype.getAll = function () {
            var keys = Object.keys(this.cacheValues);
            return this.mget(keys);
        };
        // 设置键值对。设置成功返回 true 。
        Cache.prototype.set = function (key, value, ttl) {
            if (this.options.max === 0) {
                return false;
            }
            var cacheValues = this.cacheValues;
            var keys = Object.keys(cacheValues);
            // 当前不存在该键值，并且数据量超过最大限制
            if (!cacheValues[key] && this._isLimited(keys.length)) {
                var validKeys = this.keys();
                if (this._isLimited(validKeys.length)) {
                    // 如果最大限制策略是替换，将优先替换快过期的数据，如果都是一样的过期时间(0)，按照先入先出规则处理。
                    if (this.options.maxStrategy === 'replaced') {
                        var replaceKey = this._getReplaceKey(validKeys, cacheValues);
                        this.del(replaceKey);
                    }
                    else {
                        // 如果是最大限制策略是不允许添加，返回 false 。
                        return false;
                    }
                }
            }
            cacheValues[key] = this._wrap(value, ttl);
            this.setCacheValues(cacheValues);
            this.emit('set', key, cacheValues[key].v);
            return true;
        };
        // 设置多个键值对。全部设置成功返回 true 。
        Cache.prototype.mset = function (keyValueSet) {
            var _this = this;
            // 该处不使用数组 some 方法，是因为不能某个失败，而导致其他就不在更新。
            var ret = true;
            keyValueSet.forEach(function (item) {
                var itemSetResult = _this.set(item.key, item.value, item.ttl);
                if (ret && !itemSetResult) {
                    ret = false;
                }
            });
            return ret;
        };
        // 删除一个或多个键。返回已删除条目的数量。删除永远不会失败。
        Cache.prototype.del = function (key) {
            var _this = this;
            var cacheValues = this.cacheValues;
            var count = 0;
            var keys = Array.isArray(key) ? key : [key];
            keys.forEach(function (key) {
                if (cacheValues[key]) {
                    count++;
                    var oldData = cacheValues[key];
                    delete cacheValues[key];
                    _this.emit('del', key, oldData.v);
                }
            });
            if (count > 0) {
                this.setCacheValues(cacheValues);
            }
            return count;
        };
        // 删除当前所有缓存。
        Cache.prototype.clear = function () {
            this.storage.del(this.cacheKey);
        };
        // 返回所有现有键的数组。
        Cache.prototype.keys = function () {
            var _this = this;
            var cacheValues = this.cacheValues;
            var keys = Object.keys(cacheValues);
            return keys.filter(function (key) { return _this._check(key, cacheValues[key]); });
        };
        // 当前缓存是否包含某个键。
        Cache.prototype.has = function (key) {
            var data = this.cacheValues[key];
            return !!(data && this._check(key, data));
        };
        // 获取缓存值并从缓存中删除键。
        Cache.prototype.take = function (key) {
            var ret;
            var data = this.cacheValues[key];
            if (data && this._check(key, data)) {
                ret = data.v;
                this.del(key);
            }
            return ret;
        };
        // 重新定义一个键的 ttl 。如果找到并更新成功，则返回 true 。
        Cache.prototype.ttl = function (key, ttl) {
            var cacheValues = this.cacheValues;
            var data = cacheValues[key];
            if (data && this._check(key, data)) {
                cacheValues[key] = this._wrap(data.v, ttl);
                return true;
            }
            return false;
        };
        // 获取某个键的 ttl 。
        // 如果未找到键或已过期，返回 undefined 。
        // 如果 ttl 为 0 ，返回 0 。
        // 否则返回一个以毫秒为单位的时间戳，表示键值将过期的时间。
        Cache.prototype.getTtl = function (key) {
            var cacheValues = this.cacheValues;
            var data = cacheValues[key];
            if (data && this._check(key, data)) {
                return cacheValues[key].t;
            }
            return;
        };
        // 获取某个键值的最后修改时间
        // 如果未找到键或已过期，返回 undefined 。
        // 否则返回一个以毫秒为单位的时间戳，表示键值将过期的时间。
        Cache.prototype.getLastModified = function (key) {
            var cacheValues = this.cacheValues;
            var data = cacheValues[key];
            if (data && this._check(key, data)) {
                return cacheValues[key].n;
            }
            return;
        };
        // 启动定时校验过期数据
        Cache.prototype.startCheckperiod = function () {
            var _this = this;
            // 触发全部缓存数据是否过期校验
            this.keys();
            if (this.options.checkperiod > 0) {
                clearTimeout(this._checkTimeout);
                this._checkTimeout = setTimeout(function () {
                    _this.startCheckperiod();
                }, this.options.checkperiod);
            }
        };
        // 停止定时校验过期数据
        Cache.prototype.stopCheckperiod = function () {
            clearTimeout(this._checkTimeout);
        };
        return Cache;
    }(EmitterPro));

    var AsyncMemo = (function () {
        function AsyncMemo(options) {
            this.promiseCache = {};
            this.cache = new Cache(uniqueId('uh_async_memo'), options);
        }
        AsyncMemo.prototype.run = function (asyncFn, key, options) {
            var _this = this;
            if (!key || !isString(key)) {
                return asyncFn();
            }
            var opts = __assign({ persisted: true }, options);
            if (opts.persisted) {
                var data = this.cache.get(key);
                if (data) {
                    return Promise.resolve(data);
                }
            }
            if (!this.promiseCache[key]) {
                this.promiseCache[key] = asyncFn()
                    .then(function (res) {
                    delete _this.promiseCache[key];
                    _this.cache.set(key, res, opts.ttl);
                    return res;
                })
                    .catch(function (err) {
                    delete _this.promiseCache[key];
                    return Promise.reject(err);
                });
            }
            return this.promiseCache[key];
        };
        return AsyncMemo;
    }());
    var AsyncMemo$1 = AsyncMemo;

    var mathPI = Math.PI;
    // 拼图点
    exports.Point = void 0;
    (function (Point) {
        Point[Point["None"] = 0] = "None";
        Point[Point["Outer"] = 1] = "Outer";
        Point[Point["Inner"] = 2] = "Inner";
    })(exports.Point || (exports.Point = {}));
    var pointArray = [exports.Point.None, exports.Point.Outer, exports.Point.Inner];
    // 随机选择数组中的某一项
    function pick(arr) {
        var len = arr.length;
        var randomIndex = randomInt(0, len - 1);
        return arr[randomIndex];
    }
    // 获取随机拼图点
    function getRandomPoints(pointNum) {
        var points = {
            top: pick(pointArray),
            right: pick(pointArray),
            bottom: pick(pointArray),
            left: pick(pointArray),
        };
        var pointsKeys = Object.keys(points);
        var verticalDirs = ['top', 'bottom'];
        var horizontalDirs = ['left', 'right'];
        // 保证上下 和 左右 都必须有一个外部的拼图点
        if (points.top === exports.Point.Outer && points.bottom === exports.Point.Outer) {
            points[pick(verticalDirs)] = exports.Point.Inner;
        }
        else if (points.top !== exports.Point.Outer && points.bottom !== exports.Point.Outer) {
            points[pick(verticalDirs)] = exports.Point.Outer;
        }
        if (points.left === exports.Point.Outer && points.right === exports.Point.Outer) {
            points[pick(horizontalDirs)] = exports.Point.Inner;
        }
        else if (points.left !== exports.Point.Outer && points.right !== exports.Point.Outer) {
            points[pick(horizontalDirs)] = exports.Point.Outer;
        }
        if (pointNum) {
            var inners_1 = [];
            var nones_1 = [];
            pointsKeys.forEach(function (item) {
                if (points[item] === exports.Point.Inner) {
                    inners_1.push(item);
                }
                else if (points[item] === exports.Point.None) {
                    nones_1.push(item);
                }
            });
            if (pointNum === 2) {
                inners_1.forEach(function (item) { return (points[item] = exports.Point.None); });
            }
            else if (pointNum === 3) {
                if (inners_1.length === 0) {
                    points[pick(nones_1)] = exports.Point.Inner;
                }
                else if (inners_1.length === 2) {
                    points[pick(inners_1)] = exports.Point.None;
                }
            }
            else if (pointNum == 4) {
                nones_1.forEach(function (item) { return (points[item] = exports.Point.Inner); });
            }
        }
        return points;
    }
    // 画拼图
    function drawPuzzle(ctx, options) {
        if (options === void 0) { options = {}; }
        var _a = options.x, x = _a === void 0 ? 0 : _a, _b = options.y, y = _b === void 0 ? 0 : _b, _c = options.w, w = _c === void 0 ? 60 : _c, _d = options.h, h = _d === void 0 ? 60 : _d, _e = options.needClosePath, needClosePath = _e === void 0 ? true : _e;
        var points = options.points, _f = options.margin, margin = _f === void 0 ? 0 : _f;
        margin = margin <= 0 ? 0 : margin;
        if (typeof points === 'number' || !points) {
            points = getRandomPoints(points);
        }
        var r = (Math.min(w, h) - margin * 2) * 0.15; // 适合拼图点的比例 0.15
        var l = Math.hypot(r, r); // 斜边长度
        var l1_2 = l / 2; // 斜边长度一半，45度角直角三角形，邻边相等
        var c2r = r + l1_2; // 圆直径
        var rect = {
            x: x + margin,
            y: y + margin,
            w: w - c2r - margin * 2,
            h: h - c2r - margin * 2,
        };
        var w1_2 = rect.w / 2; // 矩形一半宽度
        var h1_2 = rect.h / 2; // 矩形一半高度
        if (points.left === exports.Point.Outer) {
            rect.x += c2r;
        }
        if (points.top === exports.Point.Outer) {
            rect.y += c2r;
        }
        // draw start
        ctx.beginPath();
        ctx.lineWidth = 2;
        // top
        ctx.moveTo(rect.x, rect.y);
        if (points.top !== exports.Point.None) {
            ctx.lineTo(rect.x + w1_2 - l1_2, rect.y);
            if (points.top === exports.Point.Inner) {
                ctx.arc(rect.x + w1_2, rect.y + l1_2, r, 1.25 * mathPI, 1.75 * mathPI, true);
            }
            else {
                ctx.arc(rect.x + w1_2, rect.y - l1_2, r, 0.75 * mathPI, 0.25 * mathPI);
            }
        }
        ctx.lineTo(rect.x + rect.w, rect.y);
        // right
        if (points.right !== exports.Point.None) {
            ctx.lineTo(rect.x + rect.w, rect.y + h1_2 - l1_2);
            if (points.right === exports.Point.Inner) {
                ctx.arc(rect.x + rect.w - l1_2, rect.y + h1_2, r, 1.75 * mathPI, 0.25 * mathPI, true);
            }
            else {
                ctx.arc(rect.x + rect.w + l1_2, rect.y + h1_2, r, 1.25 * mathPI, 0.75 * mathPI);
            }
        }
        ctx.lineTo(rect.x + rect.w, rect.y + rect.h);
        // bottom
        if (points.bottom !== exports.Point.None) {
            ctx.lineTo(rect.x + w1_2 + l1_2, rect.y + rect.h);
            if (points.bottom === exports.Point.Inner) {
                ctx.arc(rect.x + w1_2, rect.y + rect.h - l1_2, r, 0.25 * mathPI, 0.75 * mathPI, true);
            }
            else {
                ctx.arc(rect.x + w1_2, rect.y + rect.h + l1_2, r, 1.75 * mathPI, 1.25 * mathPI);
            }
        }
        ctx.lineTo(rect.x, rect.y + rect.h);
        // left
        if (points.left !== exports.Point.None) {
            ctx.lineTo(rect.x, rect.y + h1_2 + l1_2);
            if (points.left === exports.Point.Inner) {
                ctx.arc(rect.x + l1_2, rect.y + h1_2, r, 0.75 * mathPI, 1.25 * mathPI, true);
            }
            else {
                ctx.arc(rect.x - l1_2, rect.y + h1_2, r, 0.25 * mathPI, 1.75 * mathPI);
            }
        }
        ctx.lineTo(rect.x, rect.y);
        ctx.stroke();
        needClosePath && ctx.closePath();
        // ctx.fillStyle = "red";
        // ctx.fill();
        // ctx.strokeRect(x, y, w, h);
    }
    function canvasToImage(canvas, formatBlob, type, quality) {
        return new Promise(function (resolve) {
            if (formatBlob) {
                canvas.toBlob(function (blob) {
                    if (blob) {
                        resolve(URL.createObjectURL(blob));
                    }
                    else {
                        resolve(canvas.toDataURL(type, quality));
                    }
                }, type, quality);
            }
            else {
                resolve(canvas.toDataURL(type, quality));
            }
        });
    }

    var asyncMemo = new AsyncMemo$1({ max: 5, maxStrategy: 'replaced' });
    asyncMemo.cache.on('del', function (k, v) {
        try {
            if (v.image.src) {
                URL.revokeObjectURL(v.image.src);
            }
        }
        catch (err) {
            /* empty */
        }
    });
    function clearCache(key) {
        if (key) {
            asyncMemo.cache.del(key);
        }
        else {
            asyncMemo.cache.clear();
        }
    }
    var wm = new WeakMap();
    var getCacheKey = function (obj) {
        if (!isObject(obj)) {
            return String(obj);
        }
        if (!wm.get(obj)) {
            wm.set(obj, uniqueId('cp'));
        }
        return wm.get(obj);
    };
    var MimeType = {
        jpeg: 'image/jpeg',
        png: 'image/png',
    };
    // 缓存之前的 blob url
    var previousBlobUrlCache = [];
    function revokeBlobUrls(blobUrls) {
        blobUrls.forEach(function (item) {
            URL.revokeObjectURL(item);
        });
    }
    // 创建拼图和背景图
    function createPuzzle(imgUrl, options) {
        if (options === void 0) { options = {}; }
        var _a = options.borderWidth, borderWidth = _a === void 0 ? 2 : _a, _b = options.borderColor, borderColor = _b === void 0 ? 'rgba(255,255,255,0.7)' : _b, _c = options.fillColor, fillColor = _c === void 0 ? 'rgba(255,255,255,0.7)' : _c, outPoints = options.points, _d = options.width, width = _d === void 0 ? 60 : _d, _e = options.height, height = _e === void 0 ? 60 : _e, outX = options.x, outY = options.y, _f = options.margin, margin = _f === void 0 ? 2 : _f, _g = options.equalHeight, equalHeight = _g === void 0 ? true : _g, imageWidth = options.imageWidth, imageHeight = options.imageHeight, outBgWidth = options.bgWidth, outBgHeight = options.bgHeight, _h = options.bgOffset, outBgOffset = _h === void 0 ? [0, 0] : _h, _j = options.bgImageType, bgImageType = _j === void 0 ? MimeType.jpeg : _j, _k = options.quality, quality = _k === void 0 ? 0.8 : _k, _l = options.format, format = _l === void 0 ? 'dataURL' : _l, _m = options.cacheImage, cacheImage = _m === void 0 ? true : _m, _o = options.autoRevokePreviousBlobUrl, autoRevokePreviousBlobUrl = _o === void 0 ? true : _o, ajaxOptions = options.ajaxOptions;
        return new Promise(function (resolve, reject) {
            var bgCanvas = document.createElement('canvas');
            var puzzleCanvas = document.createElement('canvas');
            var bgCtx = bgCanvas.getContext('2d');
            var puzzleCtx = puzzleCanvas.getContext('2d');
            var cacheKey = cacheImage ? getCacheKey(imgUrl) : undefined;
            asyncMemo
                .run(function () { return loadImageWithBlob(imgUrl, ajaxOptions); }, cacheKey)
                .then(function (_a) {
                var img = _a.image;
                if (imageWidth) {
                    img.width = imageWidth;
                }
                if (imageHeight) {
                    img.height = imageHeight;
                }
                var bgWidth = typeof outBgWidth === 'number' && outBgWidth > 0
                    ? outBgWidth > width
                        ? outBgWidth
                        : width
                    : img.width;
                var bgHeight = typeof outBgHeight === 'number' && outBgHeight > 0
                    ? outBgHeight > height
                        ? outBgHeight
                        : height
                    : img.height;
                bgCanvas.width = bgWidth;
                bgCanvas.height = bgHeight;
                var maxOffsetX = bgWidth - width;
                var maxOffsetY = bgHeight - height;
                var x = typeof outX === 'undefined' ? randomInt(width, maxOffsetX) : outX || 0;
                var y = typeof outY === 'undefined' ? randomInt(0, maxOffsetY) : outY || 0;
                if (x < 0) {
                    x = 0;
                }
                else if (x > maxOffsetX) {
                    x = maxOffsetX;
                }
                if (y < 0) {
                    y = 0;
                }
                else if (y > maxOffsetY) {
                    y = maxOffsetY;
                }
                var points = typeof outPoints === 'number' || !outPoints ? getRandomPoints(outPoints) : outPoints;
                var bgOffset = typeof outBgOffset === 'function' ? outBgOffset(img.width, img.height) : outBgOffset;
                // 背景图
                bgCtx.strokeStyle = borderColor;
                bgCtx.lineWidth = borderWidth;
                bgCtx.fillStyle = fillColor;
                drawPuzzle(bgCtx, { x: x, y: y, w: width, h: height, points: points, margin: margin });
                bgCtx.fillStyle = fillColor;
                bgCtx.fill();
                bgCtx.globalCompositeOperation = 'destination-over';
                bgCtx.drawImage(img, bgOffset[0], bgOffset[1], img.width, img.height);
                puzzleCanvas.width = bgWidth;
                puzzleCanvas.height = bgHeight;
                // 拼图
                puzzleCtx.strokeStyle = borderColor;
                puzzleCtx.lineWidth = borderWidth;
                drawPuzzle(puzzleCtx, { x: x, y: y, w: width, h: height, points: points, margin: margin });
                puzzleCtx.globalCompositeOperation = 'destination-over';
                puzzleCtx.clip();
                puzzleCtx.drawImage(img, bgOffset[0], bgOffset[1], img.width, img.height);
                // restore image
                var imgData = puzzleCtx.getImageData(x, y, width, height);
                puzzleCtx.clearRect(0, 0, bgWidth, bgHeight);
                puzzleCanvas.width = width;
                puzzleCanvas.height = equalHeight ? bgHeight : height;
                puzzleCtx.putImageData(imgData, 0, equalHeight ? y : 0);
                var formatBlob = format === 'blob';
                var puzzlePromise = canvasToImage(puzzleCanvas, formatBlob, MimeType.png, quality);
                var bgPromise = canvasToImage(bgCanvas, formatBlob, bgImageType, quality);
                Promise.all([puzzlePromise, bgPromise])
                    .then(function (_a) {
                    var puzzleUrl = _a[0], bgUrl = _a[1];
                    if (autoRevokePreviousBlobUrl) {
                        if (previousBlobUrlCache.length) {
                            revokeBlobUrls(previousBlobUrlCache);
                            previousBlobUrlCache.length = 0;
                        }
                        if (formatBlob) {
                            previousBlobUrlCache.push(bgUrl, puzzleUrl);
                        }
                    }
                    resolve({
                        puzzleUrl: puzzleUrl,
                        bgUrl: bgUrl,
                        x: x,
                        y: equalHeight ? 0 : y,
                    });
                })
                    .catch(reject);
            })
                .catch(reject);
        });
    }

    exports.clearCache = clearCache;
    exports.createPuzzle = createPuzzle;
    exports.default = createPuzzle;
    exports.drawPuzzle = drawPuzzle;
    exports.getRandomPoints = getRandomPoints;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=createPuzzle.js.map
